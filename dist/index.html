<!doctype html>
<html lang="en">
  <head>
    <title>Home</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

    <link rel="stylesheet" href="main.css">
    <!-- --- Scripts --- -->
    <script>
      // main util methods
      const w = window;
      w.html=(strs, ...ev) => {
        let f='',i=0;
        const len = strs.length;
        for(;i<len;i++) {
          if(i>0)f+=ev[i-1];
          f+=strs[i];
        }
        return f;
      };
      w.stripIndents=(strs, ...ev) => {
        let f='',i=0;
        const len=strs.length;
        for(;i<len;i++) {
          if(i>0)f+=ev[i-1];
          f+=strs[i];
        }
        const m = f.match(/^[^\S\n]*(?=\S)/gm);
        const ind = m && Math.min(...m.map(el => el.length));
        if (ind) {
          const rg = new RegExp('^.{'+ind+'}','gm');
          return f.replace(rg, '');
        }
        return f;
      };
      w.escapeHTML=html => html.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      w.htmlSafe=w.html;
      w.css=w.html;
      w.stripIndent=w.html;
      w.oneLine=w.html;
      w.oneLineTrim=w.html;
      
      const router = new class Router {
        constructor(routes) {
          this.routes = routes;
          if (this.routes['/404']) this._notFountRoute = this.routes['/404'];
      
          // regexes for parsing uri's
          this.PARAMETER_REGEXP = /([:*])(\w+)/g;
          this.WILDCARD_REGEXP = /\*/g;
          this.REPLACE_VARIABLE_REGEXP = '([^\/]+)';
          this.REPLACE_WILDCARD = '(?:.*)';
          this.FOLLOWED_BY_SLASH_REGEXP = '(?:\/$|$)';
          this.MATCH_REGEXP_FLAGS = '';
      
          // browser events for url changes
          window.addEventListener('hashchange', this._resolve.bind(this));
          window.addEventListener('DOMContentLoaded', () => {
            this._resolve();
          });
        }
      
        // uri path
        path() {
          let path = window.location.hash.replace(/.*#/, '');
          if (path.includes('?')) path = path.split('?')[0];
          if (path.charAt(0) !== '/') { path = '/'+path; }
          return path;
        }
      
        getCurrent() {
          return this._clean(window.location.href);
        }
      
        getParameters() {
          return this._extractGETParameters(this.getCurrent()).split(',').filter(a => !!a).reduce((a, b) => {
            const split = b.split('=');
            a[split[0]] = split[1];
            return a;
          }, {});
        }
      
        getParameter(name) {
          return this.getParameters()[name];
        }
      
        addParameter(name, value) {
          const url = this.getCurrent();
          const parameters = this.getParameters();
          parameters[name] = value;
          window.location.href = window.location.href.split('?')[0] + '?' + Object.keys(parameters).map(key => `${key}=${parameters[key]}`).join(',');
        }
      
        // resolve path and update page
        _resolve() {
          const path = this.path();
          const match = this._match(path);
      
          if (match === false) {
            if (this._notFountRoute) return this._changePage(this._notFountRoute);
            else return console.warn('no page found and no default not found page setup');
          }
      
          let url = path;
          let GETParameters = this._extractGETParameters(this.getCurrent());
          if (GETParameters) url += `?${GETParameters}`;
          window.location.hash = url;
          return this._changePage(match.className);
        }
      
        // change and render page
        _changePage(className) {
          // disconnect current page before rendering next one
          window.currentPageClass.disconnectedCallback();
      
          const id = '$'+className; // page var name ( $Name.somefunc() )
          window[id] = eval('new ' + className + '()');
          window.currentPageClass = window[id];
          window[id].render();
          const pageTitle = document.querySelector('title');
          if (pageTitle) pageTitle.innerText = window[id].title;
          setTimeout(() => {
            if (window[id].connectedCallback) window[id].connectedCallback();
          }, 0);
        }
      
        _clean(str) {
          if (str instanceof RegExp) return s;
          return str.replace(/\/+$/, '').replace(/^\/+/, '/');
        }
      
        _extractGETParameters(url) {
          return url.split(/\?(.*)?$/).slice(1).join('');
        }
      
        _match(url) {
          let matched = this._findMatchedRoutes(url);
          if (!matched.length) return false;
          else if (matched.length === 1) return matched[0];
          else {
            return matched.sort((a, b) => {
              if (b.params) return 1;
              return -1;
            })[0];
          }
        }
      
        _findMatchedRoutes(url) {
          return Object.keys(this.routes)
            .map(route => {
              var { regexp, paramNames } = this._replaceDynamicURLParts(this._clean(route));
              var match = url.replace(/^\/+/, '/').match(regexp);
              var params = this._regExpResultToParams(match, paramNames);
              return !match ? false : {
                match,
                route,
                params,
                className: this.routes[route]
              };
            })
            .filter(m => m && m.match[0] !== '');
        }
      
        _replaceDynamicURLParts(route) {
          let paramNames = [];
          let regexp = '';
      
          if (route instanceof RegExp) {
            regexp = route;
          } else {
            regexp = new RegExp(
              this._clean(route)
                .replace(this.PARAMETER_REGEXP, (full, dots, name) => {
                  paramNames.push(name);
                  return this.REPLACE_VARIABLE_REGEXP;
                })
                .replace(this.WILDCARD_REGEXP, this.REPLACE_WILDCARD) + this.FOLLOWED_BY_SLASH_REGEXP, this.MATCH_REGEXP_FLAGS
            );
          }
          return { regexp, paramNames };
        }
      
        _regExpResultToParams(match, names) {
          if (names.length === 0) return null;
          if (!match) return null;
          return match
            .slice(1, match.length)
            .reduce((params, value, index) => {
              if (params === null) params = {};
              params[names[index]] = decodeURIComponent(value);
              return params;
            }, null);
        }
      }({
        "/home": "Home",
        "/404": "noop",
        "/": "Home"
      });
      
      class Page {
        constructor() {}
        // called once page is renderd
        connectedCallback() {}
        // called once page is removed
        disconnectedCallback() {}
      
        // render page html
        render() {
          if (this.beforeRender) this.beforeRender();
          const renderBlock = document.querySelector('render-block-page');
          if (!renderBlock) throw Error('Could not find <render-block-page>');
          renderBlock.innerHTML = `<style>${this.styles()}</style>${this.template()}`;
          if (this.afterRender) this.afterRender();
        }
        // Called before render(). placeholder, can be overidden
        // This does not include the initial cloneNode
        beforeRender() {}
        // Called after render(). placeholder, can be overidden
        // This does not include the initial cloneNode
        afterRender() {}
      
        // add css that will be injected to the template
        styles() {}
      
        // File path from root of project
        stylesFile() {}
      
        // add html template, This will be used to create the template and direct render
        template() {}
      }
    
      // global classes
      
      window.CanvasToFileCore = class CanvasToFileCore {
        constructor(canvasElement, paletteToolElement) {
          this.canvas = canvasElement;
          this.paletteTool = paletteToolElement;
          const { rawTileData } = canvasElement.getTileData();
          this.rawTileData = rawTileData;
          this.palettes = paletteToolElement.palettes;
          this.tileWidth = canvasElement.tileWidth;
          this.tileHeight = canvasElement.tileHeight;
      
          this.tilePaletteChecker = new TilePaletteChecker(canvasElement, paletteToolElement);
        }
      
        sliceJoinArr(arr, sliceIndex, prefix = '', postfix = '') {
          const length = arr.length;
          let i = 0;
          let str = '';
      
          for (; i < length; i += sliceIndex) {
            str += `${prefix}${arr.slice(i, i + sliceIndex).join(',')}${postfix}\n`;
          }
      
          return str;
        }
      
        process(fileName, varName, tileOffset, paletteOffset) {
          this.validityData = this.tilePaletteChecker.check();
          if (this.validityData.valid === false) throw Error('You have invalid tiles, pleach check "Tile validation mode"');
      
          const palettes = this.createPaletteForFile();
          const tileArray = this.convertTileArray(this.rawTileData, palettes);
          const tilePaletteArray = this.createTilePaletteArray(parseInt(paletteOffset));
          const dedupedTiles = this.dedupTiles(tileArray, tileOffset, paletteOffset);
          const flattenedTiles = dedupedTiles.tiles.reduce((a, b) => a.concat(b), []);
          const tileMap = this.createTileMap(dedupedTiles);
          const tileDataCount = flattenedTiles.length / (this.canvas.tileWidth * 2);
          const tilesX = Math.floor(this.canvas.width / this.canvas.tileWidth);
          const tilesY = Math.floor(this.canvas.height / this.canvas.tileHeight);
          const mapCount = tilesX * tilesY;
      
          return {
            canvas: this.canvas,
            tileWidth: this.tileWidth,
            tileHeight: this.tileHeight,
            palettes,
            tilePaletteArray,
            tileArray: flattenedTiles,
            tileMap,
            tileDataCount,
            tilesX,
            tilesY,
            mapCount
          };
        }
      
        createPaletteForFile() {
          return this.palettes.map(palette => palette.map(rgba => this.convertToRGBInt(rgba)));
        }
      
        createTilePaletteArray(paletteOffset) {
          const { tileData } = this.tilePaletteChecker.check();
          return tileData.map(d => `0x0${parseInt(d.palette) + paletteOffset}`);
          // return tileData.map(d => this.convertNumberToHex(parseInt(d.palette)));
        }
      
        convertTileArray(tileArray, palettes) {
          const arrLength = tileArray.length;
          const tileWidth = this.canvas.tileWidth;
          const tileHeight = this.canvas.tileHeight;
          const pixelsPerTile = tileWidth * tileHeight;
          const rowsPerTile = pixelsPerTile / tileWidth;
          let i = 0;
          let j;
          let tempArr;
          let startingPixel;
          let palette;
          let convertedRow;
      
          for(; i < arrLength; i += 1) {
            tempArr = [];
            for (j = 0; j < rowsPerTile; j += 1) {
              startingPixel = j * tileWidth;
              palette = palettes[this.validityData.tileData[i].palette];
              convertedRow = this.convertPixelsToIndexedColor(tileArray[i].slice(startingPixel, startingPixel + tileWidth), palette);
              tempArr = tempArr.concat(this.createTilePixelRow(convertedRow));
            }
      
            tileArray[i] = tempArr;
          }
      
          return tileArray;
        }
      
        convertPixelsToIndexedColor(rgbaArr, palette) {
          return rgbaArr.map(rgba => this.matchColorToPalette(this.convertToRGBInt(rgba), palette));
        }
      
        arrayUnique(arr) {
          const newArr = [];
          arr.forEach(a => {
            const found = newArr.find(b => this.compareTiles(a, b));
            if (!found) newArr.push(a);
          });
          return newArr;
        }
      
        dedupTiles(nestedTiles, tileOffset, paletteOffset) {
          tileOffset = parseInt(tileOffset || 0);
          paletteOffset = parseInt(paletteOffset || 0);
          const tiles = this.arrayUnique(nestedTiles);
          const mapping = nestedTiles.map(a => tiles.findIndex(b => this.compareTiles(a, b))).map(v => v + tileOffset);
          const allPaletteArray = this.createTilePaletteArray(paletteOffset);
          const paletteArrayObj = mapping.reduce((a, b) => {
            a[mapping[b]] = allPaletteArray[mapping[b]];
            return a;
          }, {});
          const paletteArray = Object.keys(paletteArrayObj).sort().map(k => paletteArrayObj[k]);
          return { tiles, mapping, paletteArray };
        }
      
        compareTiles(one, two) {
          return one.join('') === two.join('');
        }
      
        createTilePixelRow(pixels) {
          let hbits = 0;
          let lbits = 0;
          let x = 0;
          let length = pixels.length;
          let p;
      
          for (; x < length; x += 1) {
            lbits = lbits << 1;
        		hbits = hbits << 1;
      
            p = pixels[x];
            if (p === 1 || p === 3) lbits += 1;
            if (p === 2 || p === 3) hbits += 1;
          }
      
          return [`0x${('00' + lbits.toString(16)).slice(-2).toUpperCase()}`, `0x${('00' + hbits.toString(16)).slice(-2).toUpperCase()}`];
        }
      
        createTileMap({ mapping }) {
          return Object.keys(mapping).reduce((a, key) => a.concat(`0x${('00' + mapping[key].toString(16)).slice(-2).toUpperCase()}`), []);
        }
      
        convertNumberToHex(n) {
          return `0x${('00' + n.toString(16)).slice(-2).toUpperCase()}`;
        }
      
        convertToRGBInt(rgba) {
          return (rgba[0] >> 3) | ((rgba[1] >> 3) << 5) | ((rgba[2] >> 3) << 10);
        }
      
        matchColorToPalette(cint, palette) {
          return palette.indexOf(cint);
        }
      
        formatFile(fileName, varName, palettes, tilePaletteArray, tileArray, tileMap) {
          const hFile = this.formatHFile(fileName, varName, palettes, tilePaletteArray, tileArray);
          const cFile = this.formatCFile(fileName, varName, palettes, tilePaletteArray, tileArray);
          const hMapFile = this.formatHMapFile(fileName, varName, tileMap);
          const cMapFile = this.formatCMapFile(fileName, varName, tileMap);
          return { hFile, cFile, hMapFile, cMapFile };
        }
      }
      window.CanvasToGameboyC = class CanvasToGameboyC {
        constructor(canvasElement, paletteToolElement) {
          this.canvas = canvasElement;
          this.canvasToFileCore = new CanvasToFileCore(canvasElement, paletteToolElement);
        }
      
        format(fileName, varName, tileOffset, paletteOffset, includeMap, includePalette) {
          const {
            canvas,
            tileWidth,
            tileHeight,
            palettes,
            tilePaletteArray,
            tileArray,
            tileMap,
            tileDataCount,
            tilesX,
            tilesY,
            mapCount
          } = this.canvasToFileCore.process(fileName, varName, tileOffset, paletteOffset);
      
          const header = this.formatHeader(fileName, palettes.length, tileDataCount, tileWidth, tileHeight, tileOffset, paletteOffset, includePalette, includeMap);
          const tileData = this.formatTileData(varName, tileArray);
          const tileDataH = this.formatTilesH(varName, palettes, tileDataCount, tilesX, tilesY, mapCount, tileOffset, paletteOffset);
      
          let cFile = `${header}\n${tileData}\n`;
          let hFile = `${header}\n${tileDataH}\n`;
      
          if (includeMap) {
            const mapData = this.formatMapData(varName, tileMap, tilePaletteArray);
            const mapH = this.formatMapH(varName);
            console.log(mapData);
      
            cFile += `${mapData}\n`;
            hFile += `${mapH}\n`;
          }
      
          return {
            cFile,
            hFile
          };
        }
      
        formatHeader(fileName, tileCount, tileDataCount, tileWidth, tileHeight, tileOffset, paletteOffset, includePalette, includeMap, type = 'c') {
          return stripIndents`
            /*
             ${fileName}.${type}
      
             Info:
              Tile size            : ${tileWidth} x ${tileHeight}
              TileDataCount        : ${tileDataCount}
              TileMapCount         : ${tileCount}
              map size             : ${Math.floor(this.canvas.width / tileWidth)} x ${Math.floor(this.canvas.height / tileHeight)}
              CGB Palette          : 1 Byte per entry.
              tileOffset           : ${tileOffset}
              paletteOffset        : ${paletteOffset}
              Includes palette     : ${!includePalette ? 'false' : 'true'}
              Includes map         : ${!includeMap ? 'false' : 'true'}
            */
          `;
        }
      
        formatTileData(varName, tileArray) {
          return stripIndents`
            /* Start of tile array. */
            unsigned char ${varName}[${tileArray.length}] = {
              ${this.canvasToFileCore.sliceJoinArr(tileArray, 16, '', ',').replace(/,\s*$/, "")}
            };
          `;
        }
      
        formatMapData(varName, mapping, tilePaletteArray) {
          return stripIndents`
            ${stripIndents`
            /* CGBpalette entries. */
            unsigned char ${varName}PaletteEntries[${tilePaletteArray.length}] = {
              ${this.canvasToFileCore.sliceJoinArr(tilePaletteArray, 20, '', ',').replace(/,\s*$/, "")}
            };
      
            /* map array. */
            unsigned char ${varName}Map[${mapping.length}] = {`}\n` +
            this.canvasToFileCore.sliceJoinArr(mapping, 20, '', ',').replace(/,\s*$/, "") +
            '\n};\n';
        }
      
        formatMapH(varName) {
          return stripIndents`
            /* CGBpalette entries. */
            extern unsigned char ${varName}PaletteEntries[];
      
            /* map array. */
            extern unsigned char ${varName}Map[];
          `;
        }
      
        formatTilesH(varName, palettes, tileDataCount, tilesX, tilesY, mapCount, tileOffset, paletteOffset) {
          return stripIndents`
            /* properties */
            #define ${varName}tileWidth ${this.canvas.tileWidth}
            #define ${varName}tileHeight ${this.canvas.tileHeight}
            #define ${varName}tilesX ${tilesX}
            #define ${varName}tilesY ${tilesY}
            #define ${varName}tileDataCount ${tileDataCount}
            #define ${varName}tileMapCount ${mapCount}
            #define ${varName}tileOffset ${tileOffset}
            #define ${varName}PaletteOffset ${paletteOffset}
      
            ${palettes.map((palette, i) => {
              return stripIndents`
                /* Gameboy Color palette ${i} */
                #define ${varName}CGBPal${i}c0 ${palette[0]}
                #define ${varName}CGBPal${i}c1 ${palette[1]}
                #define ${varName}CGBPal${i}c2 ${palette[2]}
                #define ${varName}CGBPal${i}c3 ${palette[3]}
              `;
            }).join('\n')}
      
            /* Start of tile array. */
            extern unsigned char ${varName}[];
          `;
        }
      }
      window.CanvasToGameboyS = class CanvasToGameboyZ80 {
        constructor(canvasElement, paletteToolElement) {
          this.canvas = canvasElement;
          this.canvasToFileCore = new CanvasToFileCore(canvasElement, paletteToolElement);
        }
      
        format(fileName, varName, tileOffset, paletteOffset, includeMap, includePalette) {
          const {
            canvas,
            tileWidth,
            tileHeight,
            palettes,
            tilePaletteArray,
            tileArray,
            tileMap
          } = this.canvasToFileCore.process(fileName, varName, tileOffset, paletteOffset);
          const tileDataCount = tileArray.length / (this.canvas.tileWidth * 2);
          const header = this.formatHeader(fileName, palettes.length, tileDataCount, tileWidth, tileHeight, tileOffset, paletteOffset, includePalette, includeMap);
          const tileData = this.formatTileData(varName, palettes, tilePaletteArray, tileArray, tileDataCount);
          const tileDataH = this.formatTilesH(varName, palettes);
      
          let sFile = `${header}\n${tileData}\n`;
          let hFile = `${header}\n${tileDataH}\n`;
      
          if (includeMap) {
            const mapData = this.formatMapData(varName, tileMap, tileArray);
            const mapH = this.formatMapH(varName);
      
            sFile += `${mapData}\n`;
            hFile += `${mapH}\n`;
          }
      
          console.log(sFile);
          console.log(hFile);
      
          return {
            sFile,
            hFile
          };
        }
      
        formatHeader(fileName, tileCount, tileDataCount, tileWidth, tileHeight, tileOffset, paletteOffset, includePalette, includeMap, type = 's') {
          return stripIndents`
            ; ${fileName}.${type}
      
            ; Info:
            ;  Tile size            : ${tileWidth} x ${tileHeight}
            ;  TileDataCount        : ${tileDataCount}
            ;  TileMapCount         : ${tileCount}
            ;  map size             : ${Math.floor(this.canvas.width / tileWidth)} x ${Math.floor(this.canvas.height / tileHeight)}
            ;  CGB Palette          : 1 Byte per entry.
            ;  tileOffset           : ${tileOffset}
            ;  paletteOffset        : ${paletteOffset}
            ;  Includes palette     : ${!includePalette ? 'false' : 'true'}
            ;  Includes map         : ${!includeMap ? 'false' : 'true'}
          `;
        }
      
        formatTileData(varName, palettes, tilePaletteArray, tileArray, tileDataCount, codeArea = 1) {
          const tileCount = tilePaletteArray.length;
          return stripIndents`
            .area _CODE_${codeArea}
      
            .globl _${varName}
            .dw _${varName}
            .globl _${varName}PaletteEntries
            .dw _${varName}PaletteEntries
      
            .globl _${varName}tileWidth
            _${varName}tileWidth .equ ${this.canvas.tileWidth.toString(16)}
            .globl _${varName}tileHeight
            _${varName}tileHeight .equ ${this.canvas.tileHeight.toString(16)}
            .globl _${varName}tileDataCount
            _${varName}tileCount .equ ${tileDataCount.toString(16)}
            .globl _${varName}tileMapCount
            _${varName}tileMapCount .equ ${tileCount.toString(16)}
            .globl _${varName}Size
            _${varName}Size .equ ${tilePaletteArray.length.toString(16)}
      
            ; CGBpalette entries.
            _${varName}PaletteEntries:
            ${this.canvasToFileCore.sliceJoinArr(tilePaletteArray, 8, '.db ')}
      
            _${varName}:
            ${this.canvasToFileCore.sliceJoinArr(tileArray, 16, '.db ')}
          `;
        }
      
        formatMapData(varName, mapping) {
          return stripIndents`
            /* map array. */
            .globl _${varName}Map
            .dw _${varName}Map
      
            _${varName}MapLength .equ ${mapping.length.toString(16)}
            _${varName}Map:
            ${this.canvasToFileCore.sliceJoinArr(mapping, 8, '.db ')}
          `;
        }
      
        formatMapH(varName) {
          return stripIndents`
            extern UINT8 ${varName}tileWidth;
            extern UINT8 ${varName}tileHeight;
            extern UINT8 ${varName}tileDataCount;
            extern UINT8 ${varName}tileMapCount;
            extern unsigned char ${varName}PaletteEntries[];
            extern unsigned char ${varName}[];
      
            /* map array. */
            extern unsigned char ${varName}Map[];
          `;
        }
      
        formatTilesH(varName, palettes) {
          return stripIndents`
            ${palettes.map((palette, i) => {
              return stripIndents`
                /* Gameboy Color palette ${i} */
                #define ${varName}CGBPal${i}c0 ${palette[0]}
                #define ${varName}CGBPal${i}c1 ${palette[1]}
                #define ${varName}CGBPal${i}c2 ${palette[2]}
                #define ${varName}CGBPal${i}c3 ${palette[3]}
              `;
            }).join('\n')}
      
            /* Start of tile array. */
            extern unsigned char ${varName}[];
      
            /* CGBpalette entries. */
            extern unsigned char ${varName}PaletteEntries[];
          `;
        }
      }
      window.CanvasToGameboyZ80 = class CanvasToGameboyZ80 {
        constructor(canvasElement, paletteToolElement) {
          this.canvas = canvasElement;
          this.canvasToFileCore = new CanvasToFileCore(canvasElement, paletteToolElement);
        }
      
        format(fileName, varName, tileOffset, paletteOffset, includeMap, includePalette) {
          const {
            canvas,
            tileWidth,
            tileHeight,
            palettes,
            tilePaletteArray,
            tileArray,
            tileMap,
            tileDataCount,
            tilesX,
            tilesY,
            mapCount
          } = this.canvasToFileCore.process(fileName, varName, tileOffset, paletteOffset);
      
          const header = this.formatHeader(fileName, palettes.length, tileDataCount, tileWidth, tileHeight, tileOffset, paletteOffset, includePalette, includeMap);
          const tileData = this.formatTileData(varName, palettes, tilePaletteArray, tileArray, tileDataCount, tilesX, tilesY);
          const tileDataH = this.formatTilesH(varName, palettes, tileDataCount, tilesX, tilesY, mapCount, tileOffset, paletteOffset);
      
          let zFile = `${header}\n${tileData}\n`;
          let hFile = `${header}\n${tileDataH}\n`;
      
          if (includeMap) {
            const mapData = this.formatMapData(varName, tileMap, tilePaletteArray);
            const mapH = this.formatMapH(varName);
      
            zFile += `${mapData}\n`;
            hFile += `${mapH}\n`;
          }
      
          return {
            zFile,
            hFile
          };
        }
      
        formatHeader(fileName, tileCount, tileDataCount, tileWidth, tileHeight, tileOffset, paletteOffset, includePalette, includeMap, type = 's') {
          return stripIndents`
            ; ${fileName}.${type}
      
            ; Info:
            ;  Tile size            : ${tileWidth} x ${tileHeight}
            ;  TileDataCount        : ${tileDataCount}
            ;  TileMapCount         : ${tileCount}
            ;  map size             : ${Math.floor(this.canvas.width / tileWidth)} x ${Math.floor(this.canvas.height / tileHeight)}
            ;  CGB Palette          : 1 Byte per entry.
            ;  tileOffset           : ${tileOffset}
            ;  paletteOffset        : ${paletteOffset}
            ;  Includes palette     : ${!includePalette ? 'false' : 'true'}
            ;  Includes map         : ${!includeMap ? 'false' : 'true'}
          `;
        }
      
        formatTileData(varName, palettes, tilePaletteArray, tileArray, tileDataCount, tilesX, tilesY) {
          return stripIndents`
            ${varName}tileWidth EQU $${this.canvas.tileWidth.toString(16)}
            ${varName}tileHeight EQU $${this.canvas.tileHeight.toString(16)}
            ${varName}tileDataCount EQU $${tileDataCount.toString(16)}
            ${varName}tileMapCount EQU $${tileArray.length.toString(16)}
            ${varName}tilesX = $${tilesX.toString(16)};
            ${varName}tilesY = $${tilesY.toString(16)};
            ${varName}Size EQU $${tilePaletteArray.length.toString(16)}
            ${varName}Size EQU $${tileArray.length.toString(16)}
      
            ; CGBTile entries.
            ${varName}::
            ${this.canvasToFileCore.sliceJoinArr(tileArray.map(v => v.replace('0x', '$')), 16, 'DB ')}
          `;
        }
      
        formatMapData(varName, mapping, tilePaletteArray) {
          return stripIndents`
            ; CGBpalette entries.
            ${varName}PaletteEntries::
            ${this.canvasToFileCore.sliceJoinArr(tilePaletteArray.map(v => v.replace('0x', '$')), 8, 'DB ')}
      
            /* map array. */
            ${varName}MapLength EQU $${mapping.length.toString(16)}
            ${varName}Map::
            ${this.canvasToFileCore.sliceJoinArr(mapping.map(v => v.replace('0x', '$')), 8, 'DB ')}
          `;
        }
      
        formatMapH(varName) {
          return stripIndents`
            /* CGBpalette entries. */
            extern unsigned char ${varName}PaletteEntries[];
      
            /* map array. */
            extern unsigned char ${varName}Map[];
          `;
        }
      
        formatTilesH(varName, palettes, tileDataCount, tilesX, tilesY, mapCount, tileOffset, paletteOffset) {
          return stripIndents`
            /* properties */
            #define ${varName}tileWidth ${this.canvas.tileWidth}
            #define ${varName}tileHeight ${this.canvas.tileHeight}
            #define ${varName}tilesX ${tilesX}
            #define ${varName}tilesY ${tilesY}
            #define ${varName}tileDataCount ${tileDataCount}
            #define ${varName}tileMapCount ${mapCount}
            #define ${varName}tileOffset ${tileOffset}
            #define ${varName}PaletteOffset ${paletteOffset}
      
            ${palettes.map((palette, i) => {
              return stripIndents`
                /* Gameboy Color palette ${i} */
                #define ${varName}CGBPal${i}c0 ${palette[0]}
                #define ${varName}CGBPal${i}c1 ${palette[1]}
                #define ${varName}CGBPal${i}c2 ${palette[2]}
                #define ${varName}CGBPal${i}c3 ${palette[3]}
              `;
            }).join('\n')}
      
            /* Start of tile array. */
            extern unsigned char ${varName}[];
          `;
        }
      }
      window.CanvasUtils = class CanvasUtils {
        constructor() {
          this.canvas = document.querySelector('draw-canvas');
          this.paletteElement = document.querySelector('palette-tool');;
        }
      
        get palettes() {
          return this.paletteElement.palettes;
        }
      
        get palettesInt() {
          return this.palettes.map(p => p.map(ColorUtils.RGBAtoInt));
        }
      
        canvasColors() {
          return Object.keys(
            this
              .mapTiles(t => Object.keys(t.colors))
              .reduce((a, b) => {
                b.forEach(c => a[c] = true)
                return a;
              }, {}))
              .map(i => ColorUtils.intToRGBA(parseInt(i))
          );
        }
      
        forEachTile(fn) {
          this.tilesArray().forEach(fn);
        }
      
        mapTiles(fn) {
          return this.tilesArray().map(fn);
        }
      
        tilesArray() {
          const pixelData = this.canvas.getNormalizedCanvasData().data;
          const width = this.canvas.canvasWidth;
          const height = this.canvas.canvasHeight;
          const tileWidth = this.canvas.gridSize.x;
          const tileHeight = this.canvas.gridSize.y;
          const tileRowCount = width / tileWidth;
          const tiles = [];
          let currentRow = 0;
          let pixelCounter = 0;
          let currentColumn;
          let tileIndex;
          let rawColor;
      
          for (; currentRow < height; currentRow += 1) {
            for (currentColumn = 0; currentColumn < width; currentColumn += 1) {
              tileIndex = Math.floor(currentRow / tileHeight) * tileRowCount + Math.floor(currentColumn / tileWidth);
              rawColor = [pixelData[pixelCounter], pixelData[pixelCounter + 1], pixelData[pixelCounter + 2], pixelData[pixelCounter + 3] / 255];
              if (!tiles[tileIndex]) tiles[tileIndex] = { pixels: [], colors: {} };
              tiles[tileIndex].pixels.push(rawColor);
              tiles[tileIndex].colors[ColorUtils.RGBAtoInt(rawColor)] = rawColor;
              pixelCounter += 4;
            }
          }
      
          return tiles;
        }
      }
      window.ColorUtils = class ColorUtils {
        static RGBAtoInt(arr) {
          return ((Math.round(arr[3] * 255) << 24) >>> 0 | arr[0] << 16 | arr[1] << 8 | arr[2]) >>> 0;
        }
      
        static intToRGBA(num) {
          let alpha = num >> 24 & 255;
          if (alpha > 1) alpha = alpha / 255;
          return `rgba(${num >> 16 & 255},${num >> 8  & 255},${num & 255},${alpha})`;
        }
      
        static intToRGBAArray(num) {
          let alpha = num >> 24 & 255;
          if (alpha > 1) alpha = alpha / 255;
          return [num >> 16 & 255, num >> 8  & 255, num & 255, alpha];
        }
      
        static RGBToArray(rgbString) {
          const arr = rgbString.replace('rgba(', '').replace('rgb(', '').replace(')', '').replace(/\s/g, '').split(',').map(i => parseInt(i));
          if (arr.length > 3) arr.pop();
          return arr;
        }
      
        static RGBAToArray(rgbString) {
          const arr = rgbString.replace('rgba(', '').replace('rgb(', '').replace(')', '').replace(/\s/g, '').split(',').map(i => parseInt(i));
          if (arr.length === 3) arr.push(1);
          return arr;
        }
      
        static ArrayToRBGA(arr) {
          if (arr.length === 3) arr.push(1);
          return `rgba(${arr.join(',')})`;
        }
      }
      window.Settings = class Settings {
        constructor() {
          this.data = JSON.parse(window.localStorage.getItem('tme_settings') || '{ "palettes": [], "colorMaps": [] }');
        }
      
        store() {
          window.localStorage.setItem('tme_settings', JSON.stringify(this.data));
        }
      
        get palettes() {
          return this.data.palettes || [];
        }
      
        get colorMaps() {
          return this.data.colorMaps || [];
        }
      
        savePalettes({ label, palettes }) {
          this.data.palettes.push({ id: Date.now(), label, palettes });
          this.store();
        }
      
        saveColorMap({ label, map }) {
          this.data.colorMaps.push({ id: Date.now(), label, map });
          this.store();
          document.dispatchEvent(new CustomEvent('settings-stored'));
        }
      
        removePalette(id) {
          this.data.palettes = this.data.palettes.filter(o => parseInt(o.id) !== parseInt(id));
          this.store();
        }
      
        removeColorMap(id) {
          this.data.colorMaps = this.data.colorMaps.filter(o => parseInt(o.id) !== parseInt(id));
          this.store();
        }
      
        getPaletteGroup(id) {
          id = parseInt(id);
          return (this.palettes.filter(({ id }) => id === id) || [])[0];
        }
      }
      window.TilePaletteChecker = class TilePaletteChecker {
        constructor() {
          this.canvasUtils = new CanvasUtils();
        }
      
        check() {
          const palettesInt = this.canvasUtils.palettesInt;
          const tileData = this.canvasUtils.mapTiles((tile, i) => {
            const palette = this.findPalette(palettesInt, tile.colors);
            return {
              id: i,
              valid: palette !== undefined,
              pixels: tile.pixels,
              colors: Object.keys(tile.colors).map(k => k),
              palette
            };
          });
          const invalidTiles = tileData.filter(o => !o.valid);
      
          return {
            tileData,
            invalidTiles,
            valid: invalidTiles.length === 0
          };
        }
      
        findPalette(palettes, colorObj) {
          const palLen = palettes.length;
          const colors = Object.keys(colorObj).map(i => parseInt(i));
          let i = 0;
          for(; i < palLen; i += 1) {
            if (colors.filter(cInt => !palettes[i].includes(cInt)).length === 0) {
              return i;
            }
          }
        }
      
        findColorInPalettes(palettes, cInt) {
          const length = palettes.length;
          let i = 0;
      
          for(; i < length; i += 1) {
            if (palettes[i].includes(cInt)) {
              return i;
            }
          }
      
          return -1;
        }
      }
      window.Utils = class Utils {
        static debounce(fn, wait) {
          let timer;
          return function debounced() {
            const args = arguments;
            const context = this
            clearTimeout(timer);
            timer = setTimeout(() => {
              timer = undefined;
              fn.apply(context, args);
            }, wait || 10);
          };
        }
      
        static throttle(fn, limit) {
          let alreadyQueued;
          return function throttled() {
            const args = arguments;
            const context = this;
            if (!alreadyQueued) {
              alreadyQueued = true;
              fn.apply(context, args);
              setTimeout(() => {
                alreadyQueued = false;
              }, limit);
            }
          };
        }
      
        // throttle on request animation frameyy
        static rafThrottle(fn) {
          let alreadyQueued;
          return function throttled() {
            const args = arguments;
            const context = this;
            if (!alreadyQueued) {
              alreadyQueued = true;
              fn.apply(context, args);
              requestAnimationFrame(() => {
                alreadyQueued = false;
              });
            }
          };
        }
      }
    
      // Use this in place of HTMLElement to get the advanced features
      class HTMLElementExtended extends HTMLElement {
        constructor(name) {
          super();
          this.__name = name;
        }
      
        /* Clone from pre built htmlTemplate
         *   - Rerender: replaces html but not styles. This is usefull for dynamic templates
         */
        cloneTemplate(rerender) {
          var template = document.getElementById(`${this.__name}--template`);
          var templateContent = template.content;
          var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
          var clone = templateContent.cloneNode(true);
          if (rerender) clone.querySelector('render-block').innerHTML = this.template();
          shadowRoot.appendChild(clone);
        }
      
        render() {
          if (this.removeEvents) this.removeEvents();
          if (this.beforeRender) this.beforeRender();
          const renderBlock = this.shadowRoot.querySelector('render-block');
          if (!renderBlock) throw Error('Could not find <render-block>');
          renderBlock.innerHTML = this.template();
          if (this.afterRender) this.afterRender();
          if (this.addEvents) this.addEvents();
        }
      
        // Called before render(). placeholder, can be overidden
        // This does not include the initial cloneNode
        beforeRender() {}
        // Called after render(). placeholder, can be overidden
        // This does not include the initial cloneNode
        afterRender() {}
      
        // this is called when the component is connected
        // This is also called after render, events are first remoed before render so you dont have multiple events
        addEvents() {}
        // this is called when the component is disconnected
        // This is also called prior to render, after render addEvents is called. This will make sure you old elements dont retain events
        removeEvents() {}
      
        // add css that will be injected to the template
        styles() {}
      
        // add css to the document root
        externalStyles() {}
      
        // File path from root of project
        // stylesFile() {}
      
        // add html template, This will be used to create the template and direct render
        template() {}
      }
    
      // customElemnts
      
          document.addEventListener("DOMContentLoaded", function (event) {
            (function(){
          var t=document.createElement('template');
          t.setAttribute('id','color-picker--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
      }
      
      .picking-container {
        vertical-align: top;
        position: relative;
        height: 150px;
        width: 300px;
        padding: 5px;
        user-select: none;
      }
      
      .picker {
        height: 10px;
        width: 10px;
        border: 1px white solid;
        border-radius: 11px;
        position: absolute;
        cursor: pointer;
        z-index: 10;
        user-select: none;
      }
      
      .striper {
        height: 2px;
        left: 192px;
        width: 30px;
        border: 1px white solid;
        position: absolute;
        cursor: pointer;
        z-index: 10;
        user-select: none;
      }
      
      .picking-container.no-mouse { cursor: none; }
      .picking-container.no-mouse .picker { cursor: none; }
      .picking-container.no-mouse .striper { cursor: none; }
      
      .rgba-values {
        display: inline-block;
        vertical-align: top;
        width: 65px;
        padding-left: 8px;
      }
      
      .input-container {
        flex: 1;
        display: flex;
        flex-direction: row;
        padding-bottom: 6px;
      }
      
      .input-container label {
        font-size: 14px;
        width: 24px;
      }
      
      .input-container input {
        width: 40px;
      }
          </style>
          <render-block>
            <div class="picking-container">
        <div class="picker" style="left: 180px; top: 0px;"></div>
        <div class="striper" style="top: 10px;"></div>
        <canvas id="current-color" height="150" width="30"></canvas>
        <canvas id="color-block" height="150" width="150"></canvas>
        <canvas id="color-strip" height="150" width="30"></canvas>
        <div class="rgba-values">
          <div class="input-container">
            <label for="r-value">R</label>
            <input name="r-value">
          </div>
      
          <div class="input-container">
            <label for="g-value">G</label>
            <input name="g-value">
          </div>
      
          <div class="input-container">
            <label for="b-value">B</label>
            <input name="b-value">
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("color-picker", class extends HTMLElementExtended {
        constructor() {
          super("color-picker");
      
          this.pickerX = 150;
          this.pickerY = 0;
          this.colorBlockSize = 150;
          this.colorStripWidth = 30;
          this.rgbaColor = 'rgba(255,0,0,1)';
          this.pickerColor = this.rgbaColor;
      
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.colorBlockContext.rect(0, 0, this.colorBlockSizeh1, this.colorBlockSize);
          this.fillGradient();
      
          const ctx2 = this.colorStripContext;
          ctx2.rect(0, 0, this.colorStripWidth, this.colorBlockSize);
          const grd1 = ctx2.createLinearGradient(0, 0, 0, this.colorBlockSize);
          grd1.addColorStop(0, 'rgba(255, 0, 0, 1)');
          grd1.addColorStop(0.17, 'rgba(255, 255, 0, 1)');
          grd1.addColorStop(0.34, 'rgba(0, 255, 0, 1)');
          grd1.addColorStop(0.51, 'rgba(0, 255, 255, 1)');
          grd1.addColorStop(0.68, 'rgba(0, 0, 255, 1)');
          grd1.addColorStop(0.85, 'rgba(255, 0, 255, 1)');
          grd1.addColorStop(1, 'rgba(255, 0, 0, 1)');
          ctx2.fillStyle = grd1;
          ctx2.fill();
      
          this.setBlockColor();
          this.setPickerColor();
      
          // color block
          this.bound_colorBlockMouseDown = this.colorBlockMouseDown.bind(this);
          this.bound_colorBlockMouseUp = this.colorBlockMouseUp.bind(this);
          this.bound_colorBlockMouseMove = this.colorBlockMouseMove.bind(this);
          this.colorBlock.addEventListener('mousedown', this.bound_colorBlockMouseDown);
      
          // color strip
          this.bound_colorStripMouseDown = this.colorStripMouseDown.bind(this);
          this.bound_colorStripMouseUp = this.colorStripMouseUp.bind(this);
          this.bound_colorStripMouseMove = this.colorStripMouseMove.bind(this);
          this.colorStrip.addEventListener('mousedown', this.bound_colorStripMouseDown);
        }
      
        disconnectedCallback() {
          // color block
          this.colorBlock.removeEventListener('mousedown', this.bound_colorBlockMouseDown);
          document.removeEventListener('mouseup', this.bound_colorBlockMouseUp);
          document.removeEventListener('mousemove', this.bound_colorBlockMouseMove);
      
          // color strip
          this.colorStrip.removeEventListener('mousedown', this.bound_colorStripMouseDown);
          document.removeEventListener('mouseup', this.bound_colorStripMouseUp);
          document.removeEventListener('mousemove', this.bound_colorStripMouseMove);
        }
      
        static get observedAttributes() {
          return ['max-rgb-range'];
        }
      
        attributeChangedCallback(name, oldValue, newValue) {
          if (name === 'max-rgb-range') this.maxRGBRange = newValue;
        }
      
        get color() {
          const multiplier = this.maxRGBRange / 255;
          const values = this.pickerColor.replace('rgba(', '').replace(')', '').split(',');
          return [...values.slice(0, 3).map(v => v * multiplier), 1];
        }
      
        set color(arr) {
          this.pickerColor = `rgba(${arr.join(',')})`;
          const { x, y } = this.rgbToHsl(arr);
          this.setPickerPosition(x, y);
          this.picker.style.backgroundColor = this.pickerColor;
          this.setRGBInputs();
          this.handleChange();
        }
      
        rgbToHsl([r, g, b]){
          r /= 255, g /= 255, b /= 255;
          let max = Math.max(r, g, b), min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
      
          if (max === min) {
            h = s = 0; // achromatic
          } else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
      
          return {
            x: parseInt(h * this.colorBlockSize),
            y: parseInt((1 - l) * this.colorBlockSize)
          };
      }
      
        get maxRGBRange() {
          return this.maxRGBRange_ || 255;
        }
      
        set maxRGBRange(value) {
          if (value < 3) value = 3;
          if (value > 255) value = 255;
          this.maxRGBRange_ = value;
        }
      
        get colorBlock() {
          if (!this.colorBlock_) this.colorBlock_ = this.shadowRoot.querySelector('#color-block');
          return this.colorBlock_;
        }
      
        get colorBlockContext() {
          return this.colorBlock.getContext('2d');
        }
      
        get colorStrip() {
          return this.shadowRoot.querySelector('#color-strip');
        }
      
        get colorStripContext() {
          return this.colorStrip.getContext('2d');
        }
      
        get currentColor() {
          return this.shadowRoot.querySelector('#current-color');
        }
      
        get currentColorContext() {
          return this.currentColor.getContext('2d');
        }
      
        get picker() {
          if (!this.picker_) this.picker_ = this.shadowRoot.querySelector('.picker');
          return this.picker_;
        }
      
        get striper() {
          if (!this.striper_) this.striper_ = this.shadowRoot.querySelector('.striper');
          return this.striper_;
        }
      
        get pickingContainer() {
          return this.shadowRoot.querySelector('.picking-container');
        }
      
        get rInput() {
          return this.shadowRoot.querySelector('input[name="r-value"]');
        }
      
        get gInput() {
          return this.shadowRoot.querySelector('input[name="g-value"]');
        }
      
        get bInput() {
          return this.shadowRoot.querySelector('input[name="b-value"]');
        }
      
        setBlockColor() {
          const ctx3 = this.currentColorContext;
          ctx3.fillStyle = this.pickerColor;
          ctx3.fillRect(0, 0, this.colorStripWidth, this.colorBlockSize);
        }
      
        setPickerColor() {
          const x = this.pickerX - this.colorStripWidth;
          const y = this.pickerY;
          this.pickerColor = `rgba(${[...this.colorBlockContext.getImageData(x, y, 1, 1).data].slice(0, 3).join(',')},1)`;
          if (x === 0 && y === 0) this.pickerColor = 'rgba(255,255,255,0)';
          this.picker.style.backgroundColor = this.pickerColor;
          this.setRGBInputs();
          this.handleChange();
        }
      
        setPickerPosition(x, y) {
          if (x > this.colorBlockSize + this.colorStripWidth - 1) x = this.colorBlockSize + this.colorStripWidth - 1;
          if (x < this.colorStripWidth) x = this.colorStripWidth;
          if (y < 0) y = 0;
          if (y > this.colorBlockSize) y = this.colorBlockSize;
      
          // get image data for color
          this.pickerX = x;
          this.pickerY = y;
      
          // offset picker
          if (x < this.colorStripWidth + 5) x = this.colorStripWidth + 5;
          // set picker position
          this.picker.style.left = `${x}px`;
          this.picker.style.top = `${y}px`;
        }
      
        updatePicker(x, y) {
          const rect = this.colorBlock.getBoundingClientRect();
          x -= rect.left;
          x += this.colorStripWidth;
          y -= rect.top;
      
          this.setPickerPosition(x, y);
          this.setPickerColor();
        }
      
        updateStriper(y) {
          const rect = this.colorStrip.getBoundingClientRect();
          y -= rect.top;
          if (y < 0) y = 0;
          if (y > this.colorBlockSize) y = this.colorBlockSize;
      
          this.rgbaColor = `rgba(${[...this.colorStripContext.getImageData(1, y, 1, 1).data].slice(0, 3).join(',')},1)`;
          this.striper.style.top = `${y}px`;
          this.fillGradient();
          this.setPickerColor();
        }
      
        fillGradient() {
          const ctx1 = this.colorBlockContext;
          const ctx2 = this.colorStripContext;
      
          ctx1.fillStyle = this.rgbaColor;
          ctx1.fillRect(0, 0, this.colorBlockSize, this.colorBlockSize);
      
          const grdWhite = ctx2.createLinearGradient(0, 0, this.colorBlockSize, 0);
          grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
          grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
          ctx1.fillStyle = grdWhite;
          ctx1.fillRect(0, 0, this.colorBlockSize, this.colorBlockSize);
      
          const grdBlack = ctx2.createLinearGradient(0, 0, 0, this.colorBlockSize);
          grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
          grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
          ctx1.fillStyle = grdBlack;
          ctx1.fillRect(0, 0, this.colorBlockSize, this.colorBlockSize);
        }
      
        setRGBInputs() {
          const values = this.pickerColor.replace('rgba(', '').replace(')', '').split(',');
          this.rInput.value = values[0];
          this.gInput.value = values[1];
          this.bInput.value = values[2];
        }
      
      
        // --- color block mouse events ---
      
        colorBlockMouseDown(e) {
          this.isColorBlockMouseDown = true;
          this.pickingContainer.classList.add('no-mouse');
          this.updatePicker(e.clientX, e.clientY);
          document.addEventListener('mouseup', this.bound_colorBlockMouseUp);
          document.addEventListener('mousemove', this.bound_colorBlockMouseMove);
        }
      
        colorBlockMouseUp() {
          this.isColorBlockMouseDown = false;
          this.pickingContainer.classList.remove('no-mouse');
          this.setBlockColor();
        }
      
        colorBlockMouseMove(e) {
          if (this.isColorBlockMouseDown) {
            this.updatePicker(e.clientX, e.clientY);
          }
        }
      
      
        // --- color strip mouse events ---
      
        colorStripMouseDown(e) {
          this.isColorStripMouseDown = true;
          this.pickingContainer.classList.add('no-mouse');
          this.updateStriper(e.clientY);
          document.addEventListener('mouseup', this.bound_colorStripMouseUp);
          document.addEventListener('mousemove', this.bound_colorStripMouseMove);
        }
      
        colorStripMouseUp() {
          this.isColorStripMouseDown = false;
          this.pickingContainer.classList.remove('no-mouse');
          // this.setBlockColor();
        }
      
        colorStripMouseMove(e) {
          if (this.isColorStripMouseDown) {
            this.updateStriper(e.clientY);
          }
        }
      
        handleChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              color: this.color
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
            }
      
            .picking-container {
              vertical-align: top;
              position: relative;
              height: 150px;
              width: 300px;
              padding: 5px;
              user-select: none;
            }
      
            .picker {
              height: 10px;
              width: 10px;
              border: 1px white solid;
              border-radius: 11px;
              position: absolute;
              cursor: pointer;
              z-index: 10;
              user-select: none;
            }
      
            .striper {
              height: 2px;
              left: 192px;
              width: ${this.colorStripWidth}px;
              border: 1px white solid;
              position: absolute;
              cursor: pointer;
              z-index: 10;
              user-select: none;
            }
      
            .picking-container.no-mouse { cursor: none; }
            .picking-container.no-mouse .picker { cursor: none; }
            .picking-container.no-mouse .striper { cursor: none; }
      
            .rgba-values {
              display: inline-block;
              vertical-align: top;
              width: 65px;
              padding-left: 8px;
            }
      
            .input-container {
              flex: 1;
              display: flex;
              flex-direction: row;
              padding-bottom: 6px;
            }
      
            .input-container label {
              font-size: 14px;
              width: 24px;
            }
      
            .input-container input {
              width: 40px;
            }
          `;
        }
      
        template() {
          return html`
            <div class="picking-container">
              <div class="picker" style="left: ${this.colorBlockSize + this.colorStripWidth}px; top: 0px;"></div>
              <div class="striper" style="top: 10px;"></div>
              <canvas id="current-color" height="${this.colorBlockSize}" width="${this.colorStripWidth}"></canvas>
              <canvas id="color-block" height="${this.colorBlockSize}" width="${this.colorBlockSize}"></canvas>
              <canvas id="color-strip" height="${this.colorBlockSize}" width="${this.colorStripWidth}"></canvas>
              <div class="rgba-values">
                <div class="input-container">
                  <label for="r-value">R</label>
                  <input name="r-value">
                </div>
      
                <div class="input-container">
                  <label for="g-value">G</label>
                  <input name="g-value">
                </div>
      
                <div class="input-container">
                  <label for="b-value">B</label>
                  <input name="b-value">
                </div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','palette-tool--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
      }
      
      .palette-container {
        width: 312px;
        margin: 6px;
      }
      
      .palette {
        display: flex;
        flex-direction: row;
        padding: 6px;
      }
      
      .color {
        flex: 1;
        height: 24px;
        border: 3px solid rgba(0,0,0,0);
        box-sizing: border-box;
      }
      
      .color:hover {
        border: 3px solid #AAA;
      }
      
      .color.selected {
        border: 3px solid rgb(0, 159, 218);
      }
      
      .color.selected-alt {
        border: 3px solid rgb(192, 168, 242);
      }
      
      .divider {
        border-bottom: 1px solid #999;
      }
      
      .spacer {
        padding-top: 12px;
      }
      
      .top-row {
        display: flex;
        align-items: center;
      }
      
      .title {
        font-size: 18px;
        font-weight: 400;
        padding-left: 6px;
        flex: 1;
      }
      
      .subtitle {
        font-size: 14px;
        padding-left: 6px;
        flex: 1;
      }
      
      .edit-label {
        color: #666;
        font-size: 14px;
        font-weight: bold;
        padding-right: 6px;
      }
      
      .palette-select {
        margin-left: 8px;
        margin-right: 12px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .color-block {
        flex: 1;
        height: 24px;
        margin: 8px 5px;
      }
      
      .settings {
        margin: 18px 0;
      }
      
      .settings .sub {
        margin-top: 6px;
        margin-left: 12px;
      }
      
      .setting-input {
        width: 40px;
        margin-right: 22px;
      }
          </style>
          <render-block>
            <div class="palette-container">
        <div class="top-row">
          <div class="title">Palettes</div>
          <input type="checkbox" name="edit" >
          <label class="edit-label" for="edit">Edit</label>
        </div>
      
        <div class="settings">
          <div class="subtitle">Settings</div>
      
          <div class="sub">
            <label class="edit-label" for="count">Count</label>
            <input name="count" class="setting-input" value="1">
            <label class="edit-label" for="colorCount">Color count</label>
            <input name="colorCount" class="setting-input" value="4">
          </div>
        </div>
      
        <div id="palettes">
        
                  
                  <div class="palette">
                    
                      <div class="color  selected-alt" style="background-color: rgba(255,255,255,1);" id="0:0"></div>
                    
        
                      <div class="color  " style="background-color: rgba(127,127,127,1);" id="0:1"></div>
                    
        
                      <div class="color  " style="background-color: rgba(63,63,63,1);" id="0:2"></div>
                    
        
                      <div class="color selected " style="background-color: rgba(0,0,0,1);" id="0:3"></div>
                    
                  </div>
                
        </div>
      
        <div class="spacer"></div>
        <color-picker></color-picker>
        <div class="row">
          <div id="left-color" class="color-block" style="background-color: rgba(0,0,0,1);"></div>
          <div id="right-color" class="color-block" style="background-color: rgba(255,255,255,1);"></div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("palette-tool", class extends HTMLElementExtended {
        constructor() {
          super("palette-tool");
      
          this.selectedColorLocation = [0, 3];
          this.selectedAltColorLocation = [0, 0];
      
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.debounced_dispatchPaletteChange = Utils.debounce(this.dispatchPaletteChange.bind(this), 100);
          this.bound_clickPaletteColor = this.clickPaletteColor.bind(this);
          this.bound_rightClickPaletteColor = this.rightClickPaletteColor.bind(this);
          this.bound_onColorChange = this.onColorChange.bind(this);
          this.bound_onContextMenu = this.onContextMenu.bind(this);
          this.bound_onEditCheck = this.onEditCheck.bind(this);
          this.bound_onSettingsChange = this.onSettingsChange.bind(this);
          this.addEvents();
        }
      
        disconnectedCallback() {
          this.removeEvents();
        }
      
        beforeRender() {
          this.removeEvents();
        }
      
        afterRender() {
          this.addEvents();
        }
      
        addEvents() {
          this.shadowRoot.querySelector('.palette-container').addEventListener('click', this.bound_clickPaletteColor);
          this.shadowRoot.querySelector('.palette-container').addEventListener('contextmenu', this.bound_rightClickPaletteColor);
          this.shadowRoot.querySelector('color-picker').addEventListener('change', this.bound_onColorChange);
          this.shadowRoot.querySelector('#palettes').addEventListener('contextmenu', this.bound_onContextMenu);
          this.shadowRoot.querySelector('input[type=checkbox]').addEventListener('change', this.bound_onEditCheck);
          this.shadowRoot.querySelector('input[name=count]').addEventListener('change', this.bound_onSettingsChange);
          this.shadowRoot.querySelector('input[name=colorCount]').addEventListener('change', this.bound_onSettingsChange);
        }
      
        removeEvents() {
          this.shadowRoot.querySelector('.palette-container').removeEventListener('click', this.bound_clickPaletteColor);
          this.shadowRoot.querySelector('.palette-container').removeEventListener('contextmenu', this.bound_rightClickPaletteColor);
          this.shadowRoot.querySelector('color-picker').removeEventListener('change', this.bound_onColorChange);
          this.shadowRoot.querySelector('#palettes').removeEventListener('contextmenu', this.bound_onContextMenu);
          this.shadowRoot.querySelector('input[type=checkbox]').removeEventListener('change', this.bound_onEditCheck);
          this.shadowRoot.querySelector('input[name=count]').removeEventListener('change', this.bound_onSettingsChange);
          this.shadowRoot.querySelector('input[name=colorCount]').removeEventListener('change', this.bound_onSettingsChange);
        }
      
        static get observedAttributes() {
          return ['count', 'color-count'];
        }
      
        attributeChangedCallback(name, _, newValue) {
          if (name === 'count') this.count = newValue;
          if (name === 'color-count') this.colorCount = newValue;
        }
      
        get selectedColorElement() {
          return this.shadowRoot.querySelector('.color.selected');
        }
      
        get selectedAltColorElement() {
          return this.shadowRoot.querySelector('.color.selected-alt');
        }
      
        get count() {
          return this.count_ || 1;
        }
      
        set count(value) {
          value = parseInt(value);
          if (value < 1) value = 1;
          this.count_ = value;
          this.render();
        }
      
        get colorCount() {
          return this.colorCount_ || 4;
        }
      
        // TODO regenrate color if the colorCount increases
        set colorCount(value) {
          value = parseInt(value);
          if (value < 1) value = 1;
          this.colorCount_ = value;
          this.render();
        }
      
        get palettes() {
          let change = false;
          if (!this.palettes_) this.palettes_ = [...new Array(this.count)].map(() => this.generateDefaultPalette());
          if (this.palettes_.length < this.count) {
            this.palettes_ = this.palettes_.concat([...new Array(this.count - this.palettes_.length)].map(() => this.generateDefaultPalette()));
            change = true;
          }
          if (this.palettes_.length > this.count) {
            [...new Array(this.palettes_.length - this.count)].forEach(() => this.palettes_.pop());
            change = true;
          }
          if (change) this.palettes_.forEach(p => this.updatePalette(p));
          return this.palettes_;
        }
      
        get colorPicker() {
          return this.shadowRoot.querySelector('color-picker');
        }
      
        get color() {
          return ColorUtils.ArrayToRBGA(this.palettes[this.selectedColorLocation[0]][this.selectedColorLocation[1]]);
        }
      
        set color(colorArr) {
          if (!this.isEdit) return;
          this.updateSelected(colorArr);
        }
      
        get rawColor() {
          return this.palettes[this.selectedColorLocation[0]][this.selectedColorLocation[1]];
        }
      
        get altColor() {
          return ColorUtils.ArrayToRBGA(this.palettes[this.selectedAltColorLocation[0]][this.selectedAltColorLocation[1]]);
        }
      
        get rawAltColor() {
          return this.palettes[this.selectedAltColorLocation[0]][this.selectedAltColorLocation[1]];
        }
      
        get isEdit() {
          return this.isEdit_ || false;
        }
      
        set isEdit(value) {
          this.isEdit_ = value;
        }
      
        onSettingsChange() {
          this.count = this.shadowRoot.querySelector('input[name=count]').value;
          this.colorCount = this.shadowRoot.querySelector('input[name=colorCount]').value;
        }
      
        onEditCheck(e) {
          this.isEdit = this.shadowRoot.querySelector('input[name="edit"]').checked;
        }
      
        generateDefaultPalette() {
          const step = 255 / this.colorCount;
          return [...new Array(this.colorCount)].map((_, i) => {
            const value = parseInt(step * i);
            if (i === this.colorCount - 1) return [255, 255, 255, 1];
            return [value, value, value, 1];
          }).reverse();
        }
      
        updatePalette(arr) {
          if (arr.length > this.colorCount) [...new Array(arr.length - this.colorCount)].forEach(() => arr.pop());
          if (arr.length < this.colorCount) {
            const defaults = this.generateDefaultPalette();
            [...new Array(this.colorCount - arr.length)].forEach((_, i) => arr.push(defaults[(arr.length - 1) + i]));
          }
        }
      
        setPalette(paletteId, palette) {
          const palettes = this.palettes;
          palettes[paletteId] = palette.map(p => p);
          palette.forEach((c, i) => {
            const el = this.shadowRoot.querySelector(`[id="${paletteId}:${i}"]`);
            if (el) el.style.backgroundColor = ColorUtils.ArrayToRBGA(c);
          });
          this.debounced_dispatchPaletteChange();
        }
      
        // select color
        clickPaletteColor(e) {
          // not clickomng on color block
          if (!e.target.classList.contains('color')) {
            // NOTE is this needed
            // this.dispatchChange();
            return;
          }
      
          // clear last selected color inside palette
          if (this.selectedColorElement) this.selectedColorElement.classList.remove('selected');
      
          // select new palette color
          e.target.classList.add('selected');
          this.selectedColorLocation = this.selectedColorElement.getAttribute('id').split(':').map(n => parseInt(n));
          this.render();
          this.dispatchChange();
          this.colorPicker.color = this.palettes[this.selectedColorLocation[0]][this.selectedColorLocation[1]];
        }
      
        // select alt color
        rightClickPaletteColor(e) {
          e.preventDefault();
      
          // not clickomng on color block
          if (!e.target.classList.contains('color')) {
            // NOTE is this needed
            // this.dispatchChange();
            return;
          }
      
          // clear last selected color inside palette
          if (this.selectedAltColorElement) this.selectedAltColorElement.classList.remove('selected-alt');
      
          // select new palette color
          e.target.classList.add('selected-alt');
          this.selectedAltColorLocation = this.selectedAltColorElement.getAttribute('id').split(':').map(n => parseInt(n));
          this.render();
          this.dispatchChange();
        }
      
        onColorChange(e) {
          if (this.isEdit) this.updateSelected(e.detail.color);
          this.dispatchChange();
        }
      
        updateSelected(color) {
          if (color[3] > 1) color[3] /= 255;
          this.palettes[this.selectedColorLocation[0]][this.selectedColorLocation[1]] = color;
          this.selectedColorElement.style.backgroundColor = ColorUtils.ArrayToRBGA(color);
          this.shadowRoot.querySelector('#left-color').style.backgroundColor = ColorUtils.ArrayToRBGA(color);
          this.debounced_dispatchPaletteChange();
        }
      
        // prevent context menu from showing
        onContextMenu(e) {
          e.preventDefault();
        }
      
        isSelectedColor(i, j) {
          return this.selectedColorLocation[0] === i && this.selectedColorLocation[1] === j;
        }
      
        isSelectedAltColor(i, j) {
          return this.selectedAltColorLocation[0] === i && this.selectedAltColorLocation[1] === j;
        }
      
        dispatchChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              selectedPalette: this.selectedPalette,
              selectedColor: this.rawColor,
              altColor: this.rawAltColor,
              pickerColor: this.colorPicker.color,
              palettes: this.palettes
            }
          }));
        }
      
        dispatchPaletteChange() {
          this.dispatchEvent(new CustomEvent('paletteChange', {
            detail: {
              selectedPalette: this.selectedPalette,
              selectedColor: this.rawColor,
              altColor: this.rawAltColor,
              pickerColor: this.colorPicker.color,
              palettes: this.palettes
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
            }
      
            .palette-container {
              width: 312px;
              margin: 6px;
            }
      
            .palette {
              display: flex;
              flex-direction: row;
              padding: 6px;
            }
      
            .color {
              flex: 1;
              height: 24px;
              border: 3px solid rgba(0,0,0,0);
              box-sizing: border-box;
            }
      
            .color:hover {
              border: 3px solid #AAA;
            }
      
            .color.selected {
              border: 3px solid rgb(0, 159, 218);
            }
      
            .color.selected-alt {
              border: 3px solid rgb(192, 168, 242);
            }
      
            .divider {
              border-bottom: 1px solid #999;
            }
      
            .spacer {
              padding-top: 12px;
            }
      
            .top-row {
              display: flex;
              align-items: center;
            }
      
            .title {
              font-size: 18px;
              font-weight: 400;
              padding-left: 6px;
              flex: 1;
            }
      
            .subtitle {
              font-size: 14px;
              padding-left: 6px;
              flex: 1;
            }
      
            .edit-label {
              color: #666;
              font-size: 14px;
              font-weight: bold;
              padding-right: 6px;
            }
      
            .palette-select {
              margin-left: 8px;
              margin-right: 12px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .color-block {
              flex: 1;
              height: 24px;
              margin: 8px 5px;
            }
      
            .settings {
              margin: 18px 0;
            }
      
            .settings .sub {
              margin-top: 6px;
              margin-left: 12px;
            }
      
            .setting-input {
              width: 40px;
              margin-right: 22px;
            }
          `;
        }
      
        template() {
          return html`
            <div class="palette-container">
              <div class="top-row">
                <div class="title">Palettes</div>
                <input type="checkbox" name="edit" ${this.isEdit ? 'checked' : ''}>
                <label class="edit-label" for="edit">Edit</label>
              </div>
      
              <div class="settings">
                <div class="subtitle">Settings</div>
      
                <div class="sub">
                  <label class="edit-label" for="count">Count</label>
                  <input name="count" class="setting-input" value="${this.count}">
                  <label class="edit-label" for="colorCount">Color count</label>
                  <input name="colorCount" class="setting-input" value="${this.colorCount}">
                </div>
              </div>
      
              <div id="palettes">
              ${[...new Array(this.count)].map((_, i) => `
                ${i !== 0 ? '<div class="divider"></div>' : ''}
                <div class="palette">
                  ${[...new Array(this.colorCount)].map((_, j) => `
                    <div class="color ${this.isSelectedColor(i, j) ? 'selected' : ''} ${this.isSelectedAltColor(i, j) ? 'selected-alt' : ''}" style="background-color: ${ColorUtils.ArrayToRBGA(this.palettes[i][j])};" id="${i}:${j}"></div>
                  `).join('\n')}
                </div>
              `).join('\n')}
              </div>
      
              <div class="spacer"></div>
              <color-picker></color-picker>
              <div class="row">
                <div id="left-color" class="color-block" style="background-color: ${ColorUtils.ArrayToRBGA(this.palettes[this.selectedColorLocation[0]][this.selectedColorLocation[1]])};"></div>
                <div id="right-color" class="color-block" style="background-color: ${ColorUtils.ArrayToRBGA(this.palettes[this.selectedAltColorLocation[0]][this.selectedAltColorLocation[1]])};"></div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','draw-canvas--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        cursor: none;
      }
      
      .container {
        position: relative;
        cursor: none;
      }
      
      .cursor {
        position: absolute;
        z-index: 10;
        cursor: none;
        user-select: none;
        pointer-events: none;
      }
      
      .cursor.hide {
        display: none;
      }
      
      #tile-validation-canvas {
        position: absolute;
        left: 0px;
        top: 0px;
        user-select: none;
      }
      
      #grid-canvas {
        position: absolute;
        left: 0.5px;
        top: 0.5px;
        pointer-events: none;
        user-select: none;
      }
      
      #temp-canvas,
      #temp-canvas-2 {
        position: absolute;
        display: none;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="cursor"></div>
        <canvas id="backround-canvas" width="640" height="576"></canvas>
        <canvas id="grid-canvas" width="640" height="576"></canvas>
        <canvas id="tile-validation-canvas" width="640" height="576" style="pointer-events: none;"></canvas>
      </div>
      <canvas id="temp-canvas" width="0" height="0"></canvas>
      <canvas id="temp-canvas-2" width="0" height="0"></canvas>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("draw-canvas", class extends HTMLElementExtended {
        constructor() {
          super("draw-canvas");
      
          this.canvasWidth = this.hasAttribute('width') ? parseInt(this.getAttribute('width')) : 160;
          this.canvasHeight = this.hasAttribute('height') ? parseInt(this.getAttribute('height')) : 144;
          this.scale_ = this.hasAttribute('scale') ? parseInt(this.getAttribute('scale')) : 4;
          this.color_ = [0, 0, 0, 1];
          this.tool = 'pencil';
      
          this.cloneTemplate();
        }
      
        connectedCallback() {
          const ctx = this.backgroundContext;
          this.bound_mouseDown = this.mouseDown.bind(this);
          this.bound_mouseUp = this.mouseUp.bind(this);
          this.bound_mouseLeave = this.mouseLeave.bind(this);
          this.bound_mouseMove = this.mouseMove.bind(this);
          this.bound_mouseEnter = this.mouseEnter.bind(this);
          this.bound_onContextMenu = this.onContextMenu.bind(this);
      
          // bind tile validation events
          this.bound_tileValidationMouseEnter = this.tileValidationMouseEnter.bind(this);
          this.bound_tileValidationMouseLeave = this.tileValidationMouseLeave.bind(this);
          this.bound_tileValidationMouseMove = this.tileValidationMouseMove.bind(this);
          this.bound_tileValidationClick = this.tileValidationClick.bind(this);
      
          this.addBackgroundEvents();
      
          ctx.fillStyle = 'white';
          ctx.scale(this.scale, this.scale);
          ctx.fillRect(0, 0, this.canvasWidth * this.scale, this.canvasHeight * this.scale);
      
          this.inited = true;
        }
      
        disconnectedCallback() {
          this.removeBackgroundEvents();
          this.removeTileValidationEvents();
          this.cursor_ = undefined;
        }
      
        addBackgroundEvents() {
          const canvas_ = this.backgroundCanvas;
          canvas_.addEventListener('mousedown', this.bound_mouseDown);
          canvas_.addEventListener('mouseup', this.bound_mouseUp);
          canvas_.addEventListener('mouseleave', this.bound_mouseLeave);
          canvas_.addEventListener('mousemove', this.bound_mouseMove);
          canvas_.addEventListener('mouseenter', this.bound_mouseEnter);
          canvas_.addEventListener('contextmenu', this.bound_onContextMenu);
        }
      
        removeBackgroundEvents() {
          const canvas_ = this.backgroundCanvas;
          canvas_.removeEventListener('mousedown', this.bound_mouseDown);
          canvas_.removeEventListener('mouseup', this.bound_mouseUp);
          canvas_.removeEventListener('mouseleave', this.bound_mouseLeave);
          canvas_.removeEventListener('mousemove', this.bound_mouseMove);
          canvas_.removeEventListener('mouseenter', this.bound_mouseEnter);
          canvas_.removeEventListener('contextmenu', this.bound_onContextMenu);
        }
      
        static get observedAttributes() {
          return ['width', 'height', 'scale', 'color', 'gridSize'];
        }
      
        attributeChangedCallback(name, oldValue, newValue) {
          if (!this.inited) return;
          if (name === 'scale') this.scale = newValue;
          if (name === 'color') this.color = newValue;
          if (name === 'gridSize') this.gridSize = newValue;
          if (name === 'width') this.width = newValue;
          if (name === 'height') this.height = newValue;
        }
      
        get color() {
          return this.convertToRGBA(this.color_);
        }
      
        get rawColor() {
          return this.color_;
        }
      
        set color(value) {
          if (!value) return;
          this.color_ = value;
          this.drawMainCursor();
        }
      
        get altColor() {
          return this.convertToRGBA(this.altColor_);
        }
      
        get rawAltColor() {
          return this.altColor_;
        }
      
        set altColor(value) {
          if (!value) return;
          this.altColor_ = value;
        }
      
        get backgroundCanvas() {
          return this.shadowRoot.querySelector('#backround-canvas');
        }
      
        get backgroundContext() {
          return this.backgroundCanvas.getContext('2d');
        }
      
        get gridContext() {
          return this.shadowRoot.querySelector('#grid-canvas').getContext('2d');
        }
      
        get tileValidationContext() {
          return this.shadowRoot.querySelector('#tile-validation-canvas').getContext('2d');
        }
      
        get tempCanvas() {
          return this.shadowRoot.querySelector('#temp-canvas');
        }
      
        get tempContext() {
          return this.tempCanvas.getContext('2d');
        }
      
        get tempCanvas2() {
          return this.shadowRoot.querySelector('#temp-canvas-2');
        }
      
        get tempContext2() {
          return this.tempCanvas2.getContext('2d');
        }
      
        get width() {
          return this.canvasWidth;
        }
      
        set width(value) {
          this.canvasWidth = parseInt(value);
          this.storeCanvas();
          // disconnect listenres, we are going to redraw the screen and the elements will change
          this.disconnectedCallback();
          // redraw elements
          this.render();
          // add back evnets
          if (!this.showTileValidation_) this.addBackgroundEvents();
          else this.addTileValidationEvents();
          // redraw canvas
          this.redrawCanvas();
          // optional draw grid
          if (this.showGrid_) this.drawGrid();
          if (this.showTileValidation_) this.showTileValidation();
        }
      
        get height() {
          return this.canvasHeight;
        }
      
        set height(value) {
          this.canvasHeight = parseInt(value);
          this.storeCanvas();
          // disconnect listenres, we are going to redraw the screen and the elements will change
          this.disconnectedCallback();
          // redraw elements
          this.render();
          // add back evnets
          if (!this.showTileValidation_) this.addBackgroundEvents();
          else this.addTileValidationEvents();
          // redraw canvas
          this.redrawCanvas();
          // optional draw grid
          if (this.showGrid_) this.drawGrid();
          if (this.showTileValidation_) this.showTileValidation();
        }
      
        get scale() {
          return this.scale_;
        }
      
        set scale(value) {
          value = parseFloat(value);
          if (value < 1) value = 1;
          // store canvas before scale change
          this.storeCanvas();
      
          // update scale
          this.scale_ = value;
      
          if (this.inited) {
            // disconnect listenres, we are going to redraw the screen and the elements will change
            this.disconnectedCallback();
            // redraw elements
            this.render();
            // add back evnets
            if (!this.showTileValidation_) this.addBackgroundEvents();
            else this.addTileValidationEvents();
            // redraw canvas
            this.redrawCanvas();
            // optional draw grid
            if (this.showGrid_) this.drawGrid();
            if (this.showTileValidation_) this.showTileValidation();
          }
      
          this.drawMainCursor();
        }
      
        get cursor() {
          if (!this.cursor_) this.cursor_ = this.shadowRoot.querySelector('.cursor');
          return this.cursor_;
        }
      
        get gridSize() {
          return this.gridSize_ || { x: 8, y: 8 };
        }
      
        set gridSize({ x, y }) {
          this.gridSize_ = { x, y };
          if (this.showGrid_) this.drawGrid();
        }
      
        get tileWidth() {
          return this.tileWidth_;
        }
      
        set tileWidth(value) {
          this.tileWidth_ = parseInt(value);
        }
      
        get tileHeight() {
          return this.tileHeight_;
        }
      
        set tileHeight(value) {
          this.tileHeight_ = parseInt(value);
        }
      
        // --- bockground canvas events ---
        mouseDown(e) {
          // block right click
          this.isMouseDown = true;
      
          if (this.tool === 'pencil') {
            // right
            if (e.which !== 1) this.fillPixel(e.clientX, e.clientY, this.altColor);
            // left
            else this.fillPixel(e.clientX, e.clientY, this.color);
          }
      
          if (this.tool === 'brush') {
            // right
            if (e.which !== 1) this.fillSquare(e.clientX, e.clientY, 8, 8, this.altColor);
            // left
            else this.fillSquare(e.clientX, e.clientY, 8, 8, this.color);
          }
      
          if (this.tool === 'colorPicker') {
            this.dispatchColorPick(this.getPixelColor(e.clientX, e.clientY, 1, 1));
          }
        }
      
        mouseUp(e) {
          // block right click
          if (e.which !== 1) return;
      
          if (this.isMouseDown) this.dispatchPaint();
          this.isMouseDown = false;
        }
      
        mouseLeave(e) {
          this.clearCursor();
          if (this.isMouseDown) this.dispatchPaint();
          this.isMouseDown = false;
        }
      
        dispatchPaint() {
          this.dispatchEvent(new CustomEvent('paint'));
        }
      
        mouseEnter(e) {
          switch (this.tool) {
            case 'pencil':
              this.drawMainCursor();
              break;
      
            case 'colorPicker':
              this.drawColorPickerCursor();
              break;
      
            case 'tileValidation':
              // this.drawTileValidation();
              break;
          }
      
          this.isMouseDown = false;
        }
      
        onContextMenu(e) {
          e.preventDefault();
        }
      
        mouseMove(e) {
          const bounds = this.getBoundingClientRect();
          let [x, y] = this.snapToPixel(e.clientX - bounds.left, e.clientY - bounds.top);
          this.moveCursor(x, y);
      
          if (this.isMouseDown) {
            if (this.tool === 'pencil') this.fillPixel(e.clientX, e.clientY);
          }
        }
      
      
      
        // --- cursors ---
      
        moveCursor(x, y) {
          this.cursor.style.left = `${x}px`;
          this.cursor.style.top = `${y}px`;
        }
      
        drawMainCursor() {
          this.cursor.style.width = `${this.scale}px`;
          this.cursor.style.height = `${this.scale}px`;
          this.cursor.style.backgroundColor = this.color;
          this.cursor.style.border = '1px solid #DDD';
          this.cursor.style.marginTop = 0;
        }
      
        drawPencilCursor() {
          this.drawMainCursor();
        }
      
        drawColorPickerCursor() {
          this.cursor.style.backgroundColor = null;
          this.cursor.style.background = 'url(eyedropper.svg)';
          this.cursor.style.backgroundRepeat = 'no-repeat';
          this.cursor.style.backgroundSize = '12px 12px';
          this.cursor.style.width = '12px';
          this.cursor.style.height = '12px';
          this.cursor.style.marginTop = '-8px';
        }
      
        drawBrushCursor() {
          this.cursor.style.width = `${this.scale * 8}px`;
          this.cursor.style.height = `${this.scale * 8}px`;
          this.cursor.style.backgroundColor = this.color;
          this.cursor.style.border = '1px solid #DDD';
          this.cursor.style.marginTop = 0;
        }
      
        drawTileValidationCursor() {
          this.cursor.style.width = `${this.tileWidth * this.scale}px`;
          this.cursor.style.height = `${this.tileWidth * this.scale}px`;
          this.cursor.style.border = 'none';
          this.cursor.style.marginTop = 0;
          this.redValidationCursor();
        }
      
        greenValidationCursor() {
          this.cursor.style.backgroundColor = 'rgba(117, 217, 133, 0.4)';
        }
      
        redValidationCursor() {
          this.cursor.style.backgroundColor = 'rgba(255, 50, 50, 0.1)';
        }
      
        clearCursor() {
          this.cursor.style.backgroundColor = 'rgba(0, 0, 0, 0)';
          this.cursor.style.border = 'none';
          this.cursor.style.backgroundColor = undefined;
          this.cursor.style.background = undefined;
          this.cursor.style.backgroundRepeat = undefined;
          this.cursor.style.backgroundSize = undefined;
          this.cursor.style.width = undefined;
          this.cursor.style.height = undefined;
          this.cursor.style.marginTop = 0;
        }
      
      
      
        drawImage(image, x, y) {
          this.backgroundContext.imageSmoothingEnabled = false;
          this.backgroundContext.drawImage(image, x, y);
          this.storeCanvas();
        }
      
        fillPixel(x, y, color) {
          const bounds = this.getBoundingClientRect();
          x -= bounds.left;
          y -= bounds.top;
          const [x2, y2] = this.snapToPixel(x, y);
          x = x2;
          y = y2;
      
          const ctx = this.backgroundContext;
          ctx.fillStyle = color;
          ctx.fillRect(x / this.scale, y / this.scale, 1, 1);
        }
      
        fillSquare(x, y, width, height, color) {
          const bounds = this.getBoundingClientRect();
          x -= bounds.left;
          y -= bounds.top;
          const [x2, y2] = this.snapToPixel(x, y);
          x = x2;
          y = y2;
      
          const ctx = this.backgroundContext;
          ctx.fillStyle = color;
          ctx.fillRect(x / this.scale, y / this.scale, width, height);
        }
      
        getPixelColor(x, y, width, height) {
          const bounds = this.getBoundingClientRect();
          x -= bounds.left;
          y -= bounds.top;
          const [x2, y2] = this.snapToPixel(x, y);
          x = x2;
          y = y2;
      
          return this.backgroundContext.getImageData(x, y, width, height).data;
        }
      
        snapToPixel(x, y) {
          x -= x % this.scale;
          if (x < 0) x = 0;
          y -= y % this.scale;
          if (y < 0) y = 0;
          return [x, y];
        }
      
        convertToRGBA(value) {
          return `rgba(${value.join(',')})`;
        }
      
        getPixelCount() {
          return this.canvasWidth * this.canvasHeight;
        }
      
        redrawCanvas() {
          // copy to identical canvis of ientical size
          const tempCanvas = this.tempCanvas;
          tempCanvas.width = this.canvasData.width;
          tempCanvas.height = this.canvasData.height;
          this.tempContext.putImageData(this.canvasData, 0, 0);
      
          // use draw image, this has an option for streatching
          const ctx = this.backgroundContext;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(tempCanvas, 0, 0, this.canvasData.width, this.canvasData.height, 0, 0, this.canvasWidth * this.scale, this.canvasHeight * this.scale);
          ctx.scale(this.scale, this.scale);
        }
      
        storeCanvas() {
          this.canvasData = this.backgroundContext.getImageData(0, 0, this.canvasWidth * this.scale, this.canvasHeight * this.scale);
        }
      
        getNormalizedCanvasData() {
          this.storeCanvas();
      
          // copy to identical canvis of idntical size
          const tempCanvas = this.tempCanvas;
          tempCanvas.width = this.canvasData.width;
          tempCanvas.height = this.canvasData.height;
          this.tempContext.putImageData(this.canvasData, 0, 0);
      
          // use draw image, this has an option for streatching
          const tempCanvas2 = this.tempCanvas2;
          tempCanvas2.width = this.canvasWidth;
          tempCanvas2.height = this.canvasHeight;
          const ctx = this.tempContext2;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(tempCanvas, 0, 0, this.canvasData.width, this.canvasData.height, 0, 0, this.canvasWidth, this.canvasHeight);
      
          return ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);
        }
      
        showGrid() {
          this.showGrid_ = true;
          this.drawGrid();
        }
      
        hideGrid() {
          this.showGrid_ = false;
          this.gridContext.canvas.width = this.gridContext.canvas.width;
        }
      
        drawGrid() {
          const ctx = this.gridContext;
          const width = this.canvasWidth * this.scale;
          const height = this.canvasHeight * this.scale;
          const gridSizeX = this.gridSize.x * this.scale;
          const gridSizeY = this.gridSize.y * this.scale;
          let currentColumn = gridSizeX;
          let currentRow = gridSizeY;
          ctx.canvas.width = ctx.canvas.width;
      
          while (currentColumn < width) {
            ctx.moveTo(currentColumn, 0);
            ctx.lineTo(currentColumn, height);
            currentColumn += gridSizeX;
          }
      
          while (currentRow < height) {
            ctx.moveTo(0, currentRow);
            ctx.lineTo(width, currentRow);
            currentRow += gridSizeY;
          }
      
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.stroke();
        }
      
        getTileData() {
          const pData = this.getNormalizedCanvasData().data;
          const width = this.canvasWidth;
          const height = this.canvasHeight;
          const tileWidth = this.gridSize.x;
          const tileHeight = this.gridSize.y;
          const tileRowCount = width / tileWidth;
          const tileColors = [...new Array((width / tileWidth) * (height / tileHeight))].map(() => ({}));
          const rawTileData = [...new Array((width / tileWidth) * (height / tileHeight))].map(() => ([]));
          const rawPixelData = [];
          let currentRow = 0;
          let currentColumn = 0;
          let pixelCounter = 0;
      
          let tile = 0;
          let rawColor;
      
          for (; currentRow < height; currentRow += 1) {
            for (; currentColumn < width; currentColumn += 1) {
              tile = Math.floor(currentRow / tileHeight) * tileRowCount + Math.floor(currentColumn / tileWidth);
              rawColor = [pData[pixelCounter], pData[pixelCounter + 1], pData[pixelCounter + 2], pData[pixelCounter + 3] / 255];
              rawPixelData.push(rawColor);
              tileColors[tile][ColorUtils.RGBAtoInt(rawColor)] = true;
              rawTileData[tile].push(rawColor);
              pixelCounter += 4;
            }
            currentColumn = 0;
          }
      
          return {
            rawPixelData,
            tileColors,
            rawTileData
          };
        }
      
        getAllColors() {
          const pData = this.getNormalizedCanvasData().data;
          const width = this.canvasWidth;
          const height = this.canvasHeight;
          const colors = [];
          let currentRow = 0;
          let currentColumn = 0;
          let pixelCounter = 0;
          let rawColor;
      
          for (; currentRow < height; currentRow += 1) {
            for (; currentColumn < width; currentColumn += 1) {
              rawColor = [pData[pixelCounter], pData[pixelCounter + 1], pData[pixelCounter + 2], pData[pixelCounter + 3] / 255];
              colors[ColorUtils.RGBAtoInt(rawColor)] = rawColor;
              pixelCounter += 4;
            }
            currentColumn = 0;
          }
      
          return Object.keys(colors).map(k => colors[k]);
        }
      
      
      
        // --- tile validation ---
      
        get tileValidation() {
          return this.tileValidation_;
        }
      
        set tileValidation(value) {
          this.tileValidation_ = value;
          if (value && this.showTileValidation_ === true) this.showTileValidation();
        }
      
        showTileValidation() {
          if (this.tileValidation) {
            this.showTileValidation_ = true;
            this.drawTileValidation();
            this.enableTileValidationEvents();
            this.tool = 'tileValidation';
          } else {
            console.warn('cannot show validation because "tileValidation" data was not set');
          }
        }
      
        hideTileValidation() {
          this.showTileValidation_ = false;
          const ctx = this.tileValidationContext;
          ctx.canvas.width = ctx.canvas.width;
          this.shadowRoot.querySelector('#tile-validation-canvas').style.pointerEvents = 'none';
          this.drawMainCursor();
          this.addBackgroundEvents();
          this.tool = 'pencil';
        }
      
        drawTileValidation() {
          const tileWidth = this.tileWidth * this.scale;
          const tileHeight = this.tileHeight * this.scale;
          const tileRowCount = this.canvasWidth / this.tileWidth;
          const ctx = this.tileValidationContext;
          ctx.canvas.width = ctx.canvas.width;
      
          ctx.lineWidth = 0.75;
          ctx.strokeStyle = 'rgba(238, 51, 51, 1)';
          this.tileValidation.tileData.forEach(t => {
            if (!t.valid) {
              const y = Math.floor(t.id / tileRowCount) * tileHeight;
              const x = (t.id % tileRowCount) * tileWidth;
              ctx.strokeRect(x, y, tileWidth, tileHeight);
            }
          });
        }
      
        addTileValidationEvents() {
          const canvas_ = this.shadowRoot.querySelector('#tile-validation-canvas');
          canvas_.addEventListener('mouseleave', this.bound_tileValidationMouseLeave);
          canvas_.addEventListener('mousemove', this.bound_tileValidationMouseMove);
          canvas_.addEventListener('mouseenter', this.bound_tileValidationMouseEnter);
          canvas_.addEventListener('click', this.bound_tileValidationClick);
        }
      
        removeTileValidationEvents() {
          const canvas_ = this.shadowRoot.querySelector('#tile-validation-canvas');
          canvas_.removeEventListener('mouseleave', this.bound_tileValidationMouseLeave);
          canvas_.removeEventListener('mousemove', this.bound_tileValidationMouseMove);
          canvas_.removeEventListener('mouseenter', this.bound_tileValidationMouseEnter);
          canvas_.removeEventListener('click', this.bound_tileValidationClick);
        }
      
        tileValidationMouseEnter(e) {
          this.drawTileValidationCursor();
          this.isOnTileValidationCanvas = true;
        }
      
        tileValidationMouseLeave(e) {
          this.clearCursor();
          this.isOnTileValidationCanvas = false;
        }
      
        tileValidationMouseMove(e) {
          const bounds = this.getBoundingClientRect();
          const [x, y] = this.snapToTile(e.clientX - bounds.left, e.clientY - bounds.top);
          const tileWidth = this.tileWidth * this.scale;
          // check tile validity and updat cursor color
          const isTileValid = this.tileValidation.tileData[(y / tileWidth) * (this.canvasWidth / this.tileWidth) + (x / tileWidth)].valid;
          if (isTileValid) this.greenValidationCursor();
          else this.redValidationCursor();
      
          this.moveCursor(x, y);
        }
      
        tileValidationClick(e) {
          const bounds = this.getBoundingClientRect();
          const tileWidth = this.tileWidth * this.scale;
          const tileHeight = this.tileHeight * this.scale;
          const tileRowCount = this.canvasWidth / this.tileWidth;
          let [x, y] = this.snapToTile(e.clientX - bounds.left, e.clientY - bounds.top);
          x /= tileWidth;
          y /= tileHeight;
          y *= tileRowCount;
          this.dispatchEvent(new CustomEvent('tileSelect', {
            detail: {
              selectedTile: x + y
            }
          }));
        }
      
        snapToTile(x, y) {
          x -= x % (this.tileWidth * this.scale);
          if (x < 0) x = 0;
          y -= y % (this.tileHeight * this.scale);
          if (y < 0) y = 0;
          return [x, y];
        }
      
      
        // --- events enablers ---
      
        enableDrawEvents() {
          this.disableTileValidationEvents();
          this.addBackgroundEvents();
        }
      
        disableDrawEvents() {
          this.removeBackgroundEvents();
        }
      
        enableTileValidationEvents() {
          this.disableDrawEvents();
          this.addTileValidationEvents();
          this.shadowRoot.querySelector('#tile-validation-canvas').style.pointerEvents = '';
        }
      
        disableTileValidationEvents() {
          this.removeTileValidationEvents();
          this.shadowRoot.querySelector('#tile-validation-canvas').style.pointerEvents = 'none';
        }
      
      
        getDataURL(type) {
          return this.backgroundCanvas.toDataURL(type);
        }
      
        getDownloadDataURL(type) {
          const preScale = this.scale;
          this.scale = 1;
      
          const data = this.getDataURL(type);
      
          this.scale = preScale;
          return data;
        }
      
      
      
      
      
      
      
        // --- Tools ---------------------------
      
        pencil() {
          this.clearCursor();
          this.drawPencilCursor();
          this.tool = 'pencil';
        }
      
        colorPicker() {
          this.clearCursor();
          this.drawColorPickerCursor();
          this.tool = 'colorPicker';
        }
      
        brush() {
          this.clearCursor();
          this.drawBrushCursor();
          this.tool = 'brush';
        }
      
        dispatchColorPick(colorArr) {
          this.dispatchEvent(new CustomEvent('colorPicked', {
            detail: {
              color: colorArr
            }
          }));
        }
      
      
      
      
        // ---- Draw Commands ----
      
        drawTile(tileId, tileData) {
          const ctx = this.backgroundContext;
          const tileRowCount = this.canvasWidth / this.tileWidth;
          const startY = Math.floor(tileId / tileRowCount) * this.tileHeight;
          const startX = (tileId % tileRowCount) * this.tileWidth;
          const pixelsY = this.tileHeight;
          const pixelsX = this.tileWidth;
          let counter = 0;
          let y = 0;
          let x;
      
          for(; y < pixelsY; y += 1) {
            for(x = 0; x < pixelsX; x += 1) {
              ctx.fillStyle = `rgba(${tileData[counter]})`;
              ctx.fillRect(startX + x, startY + y, 1, 1);
              counter += 1;
            }
          }
        }
      
        remapColors(colorMap) {
          this.storeCanvas();
          // invert color map to make is easier to work with
          const inversedColors = {};
          colorMap = colorMap.forEach((m, i) => {
            Object.keys(colorMap[i]).forEach(k => {
              colorMap[i][k].forEach(c => {
                inversedColors[c] = ColorUtils.RGBToArray(k);
              });
            });
          });
      
          const imageData = this.getNormalizedCanvasData();
          const pData = imageData.data;
          const length = pData.length;
          let i = 0;
          let cs;
      
          for (; i < length; i += 4) {
            cs = inversedColors[`rgb(${pData[i]}, ${pData[i + 1]}, ${pData[i + 2]})`];
            pData[i] = cs[0];
            pData[i + 1] = cs[1];
            pData[i + 2] = cs[2];
          }
      
          const tempCanvas = this.tempCanvas;
          tempCanvas.width = imageData.width;
          tempCanvas.height = imageData.height;
          this.tempContext.putImageData(imageData, 0, 0);
      
          // use draw image, this has an option for streatching
          const ctx = this.backgroundContext;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(tempCanvas, 0, 0, imageData.width, imageData.height, 0, 0, this.canvasWidth, this.canvasHeight);
        }
      
        // --- Tile manipulations ----------------------
      
        remapTilesPalette(paletteMap) {
          const updatesTiles = {};
          this.forEachTile((tile, i) => {
            if (this.compareIntPalettes(Object.keys(paletteMap), Object.keys(tile.palette))) {
              updatesTiles[i] = tile.pixels.map(c => paletteMap[ColorUtils.RGBAtoInt(c)]);
            }
            return tile;
          });
      
          Object.keys(updatesTiles).forEach(key => this.drawTile(parseInt(key), updatesTiles[key]));
        }
      
        compareIntPalettes(a, b) {
          const lengthB = b.length
          if (a.length != lengthB) return false;
      
          let i = 0;
          for (; i < lengthB; i += 1) {
            if (!a.includes(b[i])) return false;
          }
      
          return true;
        }
      
        forEachTile(fn) {
          this.getTilesArray().forEach(fn);
        }
      
        mapTiles(fn) {
          return this.getTilesArray().map(fn);
        }
      
        getTilesArray() {
          const pixelData = this.getNormalizedCanvasData().data;
          const width = this.canvasWidth;
          const height = this.canvasHeight;
          const tileWidth = this.gridSize.x;
          const tileHeight = this.gridSize.y;
          const tileRowCount = width / tileWidth;
          const tiles = [];
          let currentRow = 0;
          let pixelCounter = 0;
          let currentColumn;
          let tileIndex;
          let rawColor;
      
          for (; currentRow < height; currentRow += 1) {
            for (currentColumn = 0; currentColumn < width; currentColumn += 1) {
              tileIndex = Math.floor(currentRow / tileHeight) * tileRowCount + Math.floor(currentColumn / tileWidth);
              rawColor = [pixelData[pixelCounter], pixelData[pixelCounter + 1], pixelData[pixelCounter + 2], pixelData[pixelCounter + 3] / 255];
              if (!tiles[tileIndex]) tiles[tileIndex] = { pixels: [], palette: {} };
              tiles[tileIndex].pixels.push(rawColor);
              tiles[tileIndex].palette[ColorUtils.RGBAtoInt(rawColor)] = rawColor;
              pixelCounter += 4;
            }
          }
      
          return tiles;
        }
      
      
        styles() {
          return css`
            :host {
              display: block;
              cursor: none;
            }
      
            .container {
              position: relative;
              cursor: none;
            }
      
            .cursor {
              position: absolute;
              z-index: 10;
              cursor: none;
              user-select: none;
              pointer-events: none;
            }
      
            .cursor.hide {
              display: none;
            }
      
            #tile-validation-canvas {
              position: absolute;
              left: 0px;
              top: 0px;
              user-select: none;
            }
      
            #grid-canvas {
              position: absolute;
              left: 0.5px;
              top: 0.5px;
              pointer-events: none;
              user-select: none;
            }
      
            #temp-canvas,
            #temp-canvas-2 {
              position: absolute;
              display: none;
            }
          `;
        }
      
        template() {
          return html`
            <div class="container">
              <div class="cursor"></div>
              <canvas id="backround-canvas" width="${this.canvasWidth * this.scale}" height="${this.canvasHeight * this.scale}"></canvas>
              <canvas id="grid-canvas" width="${this.canvasWidth * this.scale}" height="${this.canvasHeight * this.scale}"></canvas>
              <canvas id="tile-validation-canvas" width="${this.canvasWidth * this.scale}" height="${this.canvasHeight * this.scale}" style="${this.showTileValidation_ ? '' : 'pointer-events: none;'}"></canvas>
            </div>
            <canvas id="temp-canvas" width="0" height="0"></canvas>
            <canvas id="temp-canvas-2" width="0" height="0"></canvas>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','scale-range--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        width: 180px;
        background-color: #DDD;
        border: 1px solid #AAA;
        border-radius: 3px;
        padding: 2px;
      }
      
      #scale-input {
        width: 20px;
        margin: 0;
      }
      
      #scale-range {
        width: 120px;
        height: 9px;
        padding-left: 4px;
      }
          </style>
          <render-block>
            <span>x</span>
      <input type="text" id="scale-input">
      <input type="range" min="1" max="10" value="" id="scale-range">
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("scale-range", class extends HTMLElementExtended {
        constructor() {
          super("scale-range");
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.bound_inputChange = this.inputChange.bind(this);
          this.bound_rangeChange = this.rangeChange.bind(this);
          this.inputEl.addEventListener('change', this.bound_inputChange);
          this.rangeEl.addEventListener('input', this.bound_rangeChange);
          this.max = this.hasAttribute('max') ? this.getAttribute('max') : 10;
          this.min = this.hasAttribute('min') ? this.getAttribute('min') : 1;
          this.value = this.hasAttribute('value') ? this.getAttribute('value') : 1;
          this.inited = true;
        }
      
        disconnectedCallback() {
          this.inputEl.removeEventListener('change', this.bound_inputChange);
          this.rangeEl.removeEventListener('input', this.bound_rangeChange);
        }
      
        static get observedAttributes() {
          return ['min', 'max'];
        }
      
        attributeChangedCallback(name, _, newValue) {
          if (name === 'min') this.min = newValue;
          if (name === 'maxt') this.max = newValue;
        }
      
        get min() {
          return this.min_;
        }
      
        set min(value) {
          value = parseInt(value);
          this.min_ = value;
        }
      
        get max() {
          return this.max_;
        }
      
        set max(value) {
          value = parseInt(value);
          this.max_ = value;
        }
      
        get inputEl() {
          return this.shadowRoot.querySelector('input[type="text"]');
        }
      
        get rangeEl() {
          return this.shadowRoot.querySelector('input[type="range"]');
        }
      
        get value() {
          return this.value_;
        }
      
        set value(v) {
          this.value_ = parseInt(v);
          if (this.value_ < this.min) this.value_ = this.min;
          if (this.value_ > this.max) this.value_ = this.max;
      
          this.rangeEl.removeEventListener('input', this.bound_inputChange);
          this.inputEl.removeEventListener('change', this.bound_inputChange);
          this.rangeEl.value = this.value_;
          this.inputEl.value = this.value_;
          this.rangeEl.addEventListener('input', this.bound_inputChange);
          this.inputEl.addEventListener('change', this.bound_inputChange);
          if (this.inited) this.handleChange();
        }
      
        inputChange(e) {
          this.value = this.inputEl.value;
        }
      
        rangeChange(e) {
          this.value = this.rangeEl.value;
        }
      
        handleChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              value: this.value
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
              width: 180px;
              background-color: #DDD;
              border: 1px solid #AAA;
              border-radius: 3px;
              padding: 2px;
            }
      
            #scale-input {
              width: 20px;
              margin: 0;
            }
      
            #scale-range {
              width: 120px;
              height: 9px;
              padding-left: 4px;
            }
          `;
        }
      
      
        template() {
          return html`
            <span>x</span>
            <input type="text" id="scale-input">
            <input type="range" min="1" max="10" value="${this.value}" id="scale-range">
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','grid-settings--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        background-color: #DDD;
        border: 1px solid #AAA;
        border-radius: 3px;
        padding: 2px;
        padding-right: 8px;
      }
      
      .pixel-input {
        width: 20px;
        margin: 0;
      }
      
      span {
        font-size: 11px;
        color: #666;
      }
      
      label {
        font-size: 13px;
        color: #444;
      }
          </style>
          <render-block>
            <span>Grid</span>
      <input type="checkbox">
      <label>X</label>
      <input type="text" class="pixel-input" id="input-x">
      <span>px</span>
      <label>Y</label>
      <input type="text" class="pixel-input" id="input-y">
      <span>px</span>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("grid-settings", class extends HTMLElementExtended {
        constructor() {
          super("grid-settings");
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.valueX = 8;
          this.valueY = 8;
          this.bound_inputXChange = this.inputXChange.bind(this);
          this.bound_inputYChange = this.inputYChange.bind(this);
          this.bound_checkboxChange = this.checkboxChange.bind(this);
          this.inputX.addEventListener('change', this.bound_inputXChange);
          this.inputY.addEventListener('change', this.bound_inputYChange);
          this.checkbox.addEventListener('change', this.bound_checkboxChange);
        }
      
        disconnectedCallback() {
          this.inputX.removeEventListener('change', this.bound_inputXChange);
          this.inputY.removeEventListener('change', this.bound_inputYChange);
          this.checkbox.removeEventListener('change', this.bound_checkboxChange);
        }
      
        get inputX() {
          return this.shadowRoot.querySelector('#input-x');
        }
      
        get inputY() {
          return this.shadowRoot.querySelector('#input-y');
        }
      
        get checkbox() {
          return this.shadowRoot.querySelector('input[type="checkbox"]');
        }
      
        get show() {
          return this.show_;
        }
      
        set show(value) {
          this.show_ = value;
        }
      
        get valueX() {
          return this.valueX_;
        }
      
        set valueX(value) {
          this.valueX_ = value;
          this.inputX.value = value;
        }
      
        get valueY() {
          return this.valueY_;
        }
      
        set valueY(value) {
          this.valueY_ = value;
          this.inputY.value = value;
        }
      
        inputXChange(e) {
          this.valueX = this.inputX.value;
          this.handleChange();
        }
      
        inputYChange(e) {
          this.valueY = this.inputY.value;
          this.handleChange();
        }
      
        checkboxChange(e) {
          this.show = this.checkbox.checked;
          this.handleChange();
        }
      
        handleChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              show: this.show,
              valueX: this.valueX,
              valueY: this.valueY
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
              background-color: #DDD;
              border: 1px solid #AAA;
              border-radius: 3px;
              padding: 2px;
              padding-right: 8px;
            }
      
            .pixel-input {
              width: 20px;
              margin: 0;
            }
      
            span {
              font-size: 11px;
              color: #666;
            }
      
            label {
              font-size: 13px;
              color: #444;
            }
          `;
        }
      
      
        template() {
          return html`
            <span>Grid</span>
            <input type="checkbox">
            <label>X</label>
            <input type="text" class="pixel-input" id="input-x">
            <span>px</span>
            <label>Y</label>
            <input type="text" class="pixel-input" id="input-y">
            <span>px</span>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','entry-dialog--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 11;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .container {
        display: inline-block;
        position: relative;
        left: 50%;
        top: 50%;
        width: 500px;
        height: auto;
        transform: translate(-50%, -50%);
      
        background-color: #DDD;
        border: 1px solid #999;
        border-radius: 3px;
        box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                    0 8px 10px 1px rgba(0,0,0,.14),
                    0 3px 14px 2px rgba(0,0,0,.12);
      }
      
      .title-bar {
        padding: 8px;
        padding-left: 16px;
        background-color: #CCC;
        border-bottom: 1px solid #aaa;
      }
      
      .title {
        font-size: 22px;
        font-weight: bold;
        color: #444;
      }
      
      .sub-title {
        font-size: 20px;
        color: #444;
        margin-bottom: 18px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      .choice-container {
        display: flex;
        flex-direction: row;
        padding: 24px;
      }
      
      .choice-1 {
        flex: 3;
        display: flex;
        flex-direction: column;
      }
      
      .choice-2 {
        flex: 2;
        display: flex;
        flex-direction: column;
      }
      
      .control-container {
        padding-bottom: 20px;
      }
      
      .control-container label {
        font-size: 17px;
        color: #666;
      }
      
      .control-container input {
        width: 40px;
      }
      
      .control-container span {
        color: #999;
        font-size: 11px;
        padding-right: 16px;
      }
      
      .controls {
        padding-top: 12px;
      }
      
      button {
        align-items: center;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
        display: inline-flex;
        font-size: 14px;
        font-weight: 500;
        height: 33px;
        justify-content: center;
        line-height: 32px;
        min-width: 64px;
        outline: none;
        overflow: hidden;
        padding: 0 8px 0 8px;
        position: relative;
        vertical-align: middle;
        margin: 0;
        background-color: white;
      }
      
      button:hover {
        cursor: pointer;
        background-color: #EEE;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="choice-container">
          <div class="choice-1">
            <span class="sub-title">Create</span>
      
            <div class="sub-header">Canvas size</div>
            <div class="control-container">
              <label for="tile-count-x">x</label>
              <input name="tile-count-x" type="number" value="20" >
              <span>Tiles</span>
              <label for="tile-count-y">y</label>
              <input name="tile-count-y" type="number" value="18" >
              <span>Tiles</span>
            </div>
      
            <div class="sub-header">Tile size</div>
            <div class="control-container">
              <label for="tile-x">x</label>
              <input name="tile-x" type="number" value="8" >
              <span>px</span>
      
              <label for="tile-y">y</label>
              <input name="tile-y" type="number" value="8" >
              <span>px</span>
            </div>
      
            <div class="sub-header">Palettes</div>
            <div class="control-container">
              <label for="palette-count">count </label>
              <input name="palette-count" type="number" value="1" >
              <br/>
              <label for="palette-color-count">colors</label>
              <input name="palette-color-count" type="number" value="4" >
              <span>per palette</span>
            </div>
      
            <div class="controls">
              <button id="create">create</button>
            </div>
          </div>
          <div class="choice-2">
            <span class="sub-title">Open</span>
            <div class="controls">
              <button>choose...</button>
            </div>
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("entry-dialog", class extends HTMLElementExtended {
        constructor() {
          super("entry-dialog");
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.bound_create = this.create.bind(this);
          this.createButton.addEventListener('click', this.bound_create);
        }
      
        disconnectedCallback() {
          this.createButton.removeEventListener('click', this.bound_create);
        }
      
        get createButton() {
          return this.shadowRoot.querySelector('#create');
        }
      
        get tileCountX() {
          return this.shadowRoot.querySelector('input[name="tile-count-x"]').value;
        }
      
        get tileCountY() {
          return this.shadowRoot.querySelector('input[name="tile-count-y"]').value;
        }
      
        get pixelsX() {
          return this.tileCountX * this.tileX;
        }
      
        get pixelsY() {
          return this.tileCountY * this.tileY;
        }
      
        get tileX() {
          return this.shadowRoot.querySelector('input[name="tile-x"]').value;
        }
      
        get tileY() {
          return this.shadowRoot.querySelector('input[name="tile-y"]').value;
        }
      
        get paletteCount() {
          return this.shadowRoot.querySelector('input[name="palette-count"]').value;
        }
      
        get paletteColorCount() {
          return this.shadowRoot.querySelector('input[name="palette-color-count"]').value;
        }
      
        create() {
          this.dispatchEvent(new CustomEvent('create', {
            detail: {
              size: {
                tileCountX: this.tileCountX,
                tileCountY: this.tileCountY,
                x: this.pixelsX,
                y: this.pixelsY
              },
              tile: {
                x: this.tileX,
                y: this.tileY
              },
              palette: {
                count: this.paletteCount,
                colorCount: this.paletteColorCount
              }
            }
          }));
          this.remove();
        }
      
        styles() {
          return css`
            :host {
              display: block;
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              z-index: 11;
              background-color: rgba(0, 0, 0, 0.5);
            }
      
            .container {
              display: inline-block;
              position: relative;
              left: 50%;
              top: 50%;
              width: 500px;
              height: auto;
              transform: translate(-50%, -50%);
      
              background-color: #DDD;
              border: 1px solid #999;
              border-radius: 3px;
              box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                          0 8px 10px 1px rgba(0,0,0,.14),
                          0 3px 14px 2px rgba(0,0,0,.12);
            }
      
            .title-bar {
              padding: 8px;
              padding-left: 16px;
              background-color: #CCC;
              border-bottom: 1px solid #aaa;
            }
      
            .title {
              font-size: 22px;
              font-weight: bold;
              color: #444;
            }
      
            .sub-title {
              font-size: 20px;
              color: #444;
              margin-bottom: 18px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            .choice-container {
              display: flex;
              flex-direction: row;
              padding: 24px;
            }
      
            .choice-1 {
              flex: 3;
              display: flex;
              flex-direction: column;
            }
      
            .choice-2 {
              flex: 2;
              display: flex;
              flex-direction: column;
            }
      
            .control-container {
              padding-bottom: 20px;
            }
      
            .control-container label {
              font-size: 17px;
              color: #666;
            }
      
            .control-container input {
              width: 40px;
            }
      
            .control-container span {
              color: #999;
              font-size: 11px;
              padding-right: 16px;
            }
      
            .controls {
              padding-top: 12px;
            }
      
            button {
              align-items: center;
              border: none;
              border-radius: 4px;
              box-sizing: border-box;
              display: inline-flex;
              font-size: 14px;
              font-weight: 500;
              height: 33px;
              justify-content: center;
              line-height: 32px;
              min-width: 64px;
              outline: none;
              overflow: hidden;
              padding: 0 8px 0 8px;
              position: relative;
              vertical-align: middle;
              margin: 0;
              background-color: white;
            }
      
            button:hover {
              cursor: pointer;
              background-color: #EEE;
            }
          `;
        }
      
      
        template() {
          return html`
            <div class="container">
              <div class="choice-container">
                <div class="choice-1">
                  <span class="sub-title">Create</span>
      
                  <div class="sub-header">Canvas size</div>
                  <div class="control-container">
                    <label for="tile-count-x">x</label>
                    <input name="tile-count-x" type="number" value="20" >
                    <span>Tiles</span>
                    <label for="tile-count-y">y</label>
                    <input name="tile-count-y" type="number" value="18" >
                    <span>Tiles</span>
                  </div>
      
                  <div class="sub-header">Tile size</div>
                  <div class="control-container">
                    <label for="tile-x">x</label>
                    <input name="tile-x" type="number" value="8" >
                    <span>px</span>
      
                    <label for="tile-y">y</label>
                    <input name="tile-y" type="number" value="8" >
                    <span>px</span>
                  </div>
      
                  <div class="sub-header">Palettes</div>
                  <div class="control-container">
                    <label for="palette-count">count </label>
                    <input name="palette-count" type="number" value="1" >
                    <br/>
                    <label for="palette-color-count">colors</label>
                    <input name="palette-color-count" type="number" value="4" >
                    <span>per palette</span>
                  </div>
      
                  <div class="controls">
                    <button id="create">create</button>
                  </div>
                </div>
                <div class="choice-2">
                  <span class="sub-title">Open</span>
                  <div class="controls">
                    <button>choose...</button>
                  </div>
                </div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','tile-palette-validator--template');
          t.innerHTML=`
          <style>
            :host {
        position: absolute;
        left: 0;
        right: 0;
        display: block;
        background-color: #DDD;
        border-left: 1px solid #AAA;
        border-right: 1px solid #AAA;
        padding: 4px;
        padding-right: 8px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      label {
        color: #666;
        font-size: 14px;
        font-weight: bold;
        padding-right: 6px;
      }
      
      .label {
        font-size: 14px;
        font-weight: bold;
        color: #777;
      }
      
      .value {
        width: 40px;
        padding-left: 4px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .column {
        display: flex;
        flex-direction: column;
      }
      
      section {
        margin-top: 6px;
        padding: 6px;
      }
      
      .reason {
        font-size: 12px;
        color: #777;
        margin-top: -8px;
        margin-left: 1px;
        margin-bottom: 12px;
      }
      
      .reason.warn {
        color: #ff3a3a;
      }
      
      .reason.success {
        color: #8aff39;
      }
      
      .tile-spacer {
        height: 80px;
        margin-left: 24px;
        margin-right: 24px;
        border-left: 1px solid #444;
      }
      
      .palette-displays,
      .palette-tile {
        margin-right: 24px;
        border: 2px solid rgba(0, 0, 0, 0);
      }
      
      .palette-tile:hover {
        border: 2px solid rgb(0, 255, 48);
        cursor: pointer;
      }
      
      .selected-display {
        margin-right: 49px;
      }
      
      button {
        cursor: pointer;
      }
      
      #fix-tile {
        width: 80px;
        margin-right: 24px;
      }
          </style>
          <render-block>
            <div class="row">
        <input id="validation-mode-checkbox" type="checkbox" >
        <label style="padding-right: 8px;">Tile validation mode</label>
      
      
        <span style="flex: 1"></span>
        <span class="label">Invalid tiles: </span><span class="value"></span>
      </div>
      
      <section>
        <div class="sub-header">Selected tile</div>
        <div>
          <div class="reason">No tile selected</div>
        </div>
      </section>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("tile-palette-validator", class extends HTMLElementExtended {
        constructor() {
          super("tile-palette-validator");
      
          this.tileDisplayWidth = 80;
          this.tileDisplayHeight = 80;
          this.tileDrawScale = 10;
      
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.tilePaletteChecker = new TilePaletteChecker();
          this.bound_onTileSelect = this.onTileSelect.bind(this);
          this.bound_onCheckboxChange = this.onCheckboxChange.bind(this);
          this.bound_onPaletteChange = this.onPaletteChange.bind(this);
          this.bound_paletteTileClick = this.paletteTileClick.bind(this);
          this.bound_applyChanges = this.applyChanges.bind(this);
          this.bound_fixTile = this.fixTile.bind(this);
          this.addEvents();
        }
      
        disconnectedCallback() {
          this.removeEvents();
        }
      
        beforeRender() {
          this.removeEvents();
        }
      
        afterRender() {
          const colorDisplays = [...this.shadowRoot.querySelectorAll('palette-display')];
          if (colorDisplays.length) {
            const selected = colorDisplays.shift();
            selected.colors = this.selectedPalette;
            colorDisplays.forEach((el, i) => el.colors = this.paletteTool.palettes[i])
          }
          this.addEvents();
        }
      
        addEvents() {
          this.validationModeCheckbox.addEventListener('change', this.bound_onCheckboxChange);
      
          if (this.paletteTool) {
            if (this.validationModeChecked_) this.paletteTool.addEventListener('paletteChange', this.bound_onPaletteChange);
          }
      
          if (this.canvas_) {
            this.canvas_.addEventListener('tileSelect', this.bound_onTileSelect);
          }
      
          const paletteTiles = [...this.shadowRoot.querySelectorAll('.palette-tile')];
          paletteTiles.forEach(el => el.addEventListener('click', this.bound_paletteTileClick));
          if (this.shadowRoot.querySelector('#apply-changes')) this.shadowRoot.querySelector('#apply-changes').addEventListener('click', this.bound_applyChanges);
          if (this.shadowRoot.querySelector('#fix-tile')) this.shadowRoot.querySelector('#fix-tile').addEventListener('click', this.bound_fixTile);
        }
      
        removeEvents() {
          this.validationModeCheckbox.removeEventListener('change', this.bound_onCheckboxChange);
      
          if (this.paletteTool) this.paletteTool.removeEventListener('paletteChange', this.bound_onPaletteChange);
      
          if (this.canvas_) {
            this.canvas_.removeEventListener('tileSelect', this.bound_onTileSelect);
          }
      
          const paletteTiles = [...this.shadowRoot.querySelectorAll('.palette-tile')];
          paletteTiles.forEach(el => el.removeEventListener('click', this.bound_paletteTileClick));
          if (this.shadowRoot.querySelector('#apply-changes')) this.shadowRoot.querySelector('#apply-changes').removeEventListener('click', this.bound_applyChanges);
          if (this.shadowRoot.querySelector('#fix-tile')) this.shadowRoot.querySelector('#fix-tile').removeEventListener('click', this.bound_fixTile);
        }
      
        get canvas() {
          return this.canvas_;
        }
      
        set canvas(value) {
          this.canvas_ = value;
          // calculate width based on aspect ratio of tile
          this.tileDisplayWidth = (this.canvas_.tileWidth / this.canvas_.tileHeight) * this.tileDisplayHeight;
          this.tileDrawScale = this.tileDisplayHeight / this.canvas_.tileHeight;
          this.canvas_.addEventListener('tileSelect', this.bound_onTileSelect);
        }
      
        get paletteTool() {
          return this.paletteTool_;
        }
      
        set paletteTool(value) {
          this.paletteTool_ = value;
        }
      
        get validationModeCheckbox() {
          return this.shadowRoot.querySelector('#validation-mode-checkbox');
        }
      
        check() {
          this.data = this.tilePaletteChecker.check();
          this.tileData = this.data.tileData;
          this.canvas.tileValidation = this.data;
          this.render();
        }
      
        showCanvas() {
          this.canvas.showTileValidation();
        }
      
        hideCanvas() {
          this.canvas.hideTileValidation();
        }
      
        onCheckboxChange(e) {
          if (this.validationModeCheckbox.checked) {
            this.validationModeChecked_ = true;
            this.check();
            this.showCanvas();
            this.paletteTool.addEventListener('paletteChange', this.bound_onPaletteChange);
          } else {
            this.validationModeChecked_ = false;
            this.selected = undefined;
            this.hideCanvas();
            this.render();
            this.paletteTool.removeEventListener('paletteChange', this.bound_onPaletteChange);
          }
        }
      
        onTileSelect(e) {
          this.selected = e.detail.selectedTile;
          this.selectedValidation = this.tileData[this.selected];
          this.selectedPalette = this.paletteTool.palettes[this.selectedValidation.palette];
          this.originalPalette = this.selectedPalette !== undefined ? this.selectedPalette : this.createTempPalette();
          this.preventTileDataReload = false;
          this.render();
          this.drawPaletteVariations();
        }
      
        paletteTileClick(e) {
          const id = e.target.getAttribute('id');
          const index = id.split('-').pop();
          this.selectedPalette = this.paletteTool.palettes[index];
          this.render();
          this.drawPaletteVariations();
          this.shadowRoot.querySelector('#apply-changes').addEventListener('click', this.bound_applyChanges);
          this.shadowRoot.querySelector('#fix-tile').addEventListener('click', this.bound_fixTile);
        }
      
        drawTile(selector, palette) {
          const tileCanvas = this.shadowRoot.querySelector(selector);
          if (!tileCanvas) return;
      
          const ctx = tileCanvas.getContext('2d');
          const isSelectedTile = selector === '#selected-tile-canvas';
          if (isSelectedTile) this.selectedTileData = [];
          const pixelScale = this.tileDrawScale;
          const tileData = this.tileData;
          const pixelsX = this.canvas.tileWidth;
          const pixelsY = this.canvas.tileHeight;
          let x;
          let y = 0;
          let palettePosition;
          let currentPixelColor;
          let noPaletttePalette = [];
      
          for(; y < pixelsY; y += 1) {
            for(x = 0; x < pixelsX; x += 1) {
              currentPixelColor = ColorUtils.RGBAtoInt(tileData[this.selected].pixels[y * pixelsX + x]);
              palettePosition = this.originalPalette.map(c => ColorUtils.RGBAtoInt(c)).indexOf(currentPixelColor);
      
              if (palette) {
                ctx.fillStyle = `rgba(${palette[palettePosition]})`;
                ctx.fillRect(x * pixelScale, y * pixelScale, pixelScale, pixelScale);
                if (isSelectedTile) this.selectedTileData.push(palette[palettePosition]);
              } else {
                ctx.fillStyle = `rgba(${tileData[y * pixelsX + x]})`;
                ctx.fillRect(x * pixelScale, y * pixelScale, pixelScale, pixelScale);
                noPaletttePalette[currentPixelColor] = tileData[y * pixelsX + x];
              }
            }
          }
        }
      
        createTempPalette() {
          const tileColors = this.tileData[this.selected].colors.sort().map(c => ColorUtils.intToRGBAArray(c));
          if (tileColors.length < 4) {
            let i = tileColors.length;
            const length = 4;
            for(; i < length; i += 1) {
              tileColors.push([i * 50, i * 50, i * 50, 1]);
            }
          }
          return tileColors;
        }
      
        drawPaletteVariations() {
          this.clearTiles();
      
          // draw current tile in selected spot
          this.drawTile('#selected-tile-canvas', this.selectedPalette);
      
          this.paletteTool.palettes.forEach((palette, i) => {
            this.drawTile(`#palette-tile-canvas-${i}`, palette);
          });
        }
      
        clearTiles() {
          this.shadowRoot.querySelector('#selected-tile-canvas').width = this.tileDisplayWidth;
          this.paletteTool.palettes.forEach((palette, i) => {
            this.shadowRoot.querySelector(`#palette-tile-canvas-${i}`).width = this.tileDisplayWidth;
          })
        }
      
        onPaletteChange(e) {
          this.check();
          this.selectedValidation = this.tileData[this.selected];
          this.drawPaletteVariations();
        }
      
        applyChanges(e) {
          this.canvas.drawTile(this.selected, this.selectedTileData);
        }
      
        fixTile() {
          this.shadowRoot.querySelector('div').insertAdjacentHTML('afterbegin', `<tile-palette-fixer tile-width="${this.canvas.tileWidth}" tile-height="${this.canvas.tileHeight}"></tile-palette-fixer>`);
          const el = this.shadowRoot.querySelector('tile-palette-fixer');
          el.setData(this.selected, this.tileData[this.selected].pixels, this.paletteTool.palettes.reduce((a, b) => a.concat(b), []), this.canvas);
          el.addEventListener('change', () => {
            this.onPaletteChange();
          });
        }
      
        styles() {
          return css`
            :host {
              position: absolute;
              left: 0;
              right: 0;
              display: block;
              background-color: #DDD;
              border-left: 1px solid #AAA;
              border-right: 1px solid #AAA;
              padding: 4px;
              padding-right: 8px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            label {
              color: #666;
              font-size: 14px;
              font-weight: bold;
              padding-right: 6px;
            }
      
            .label {
              font-size: 14px;
              font-weight: bold;
              color: #777;
            }
      
            .value {
              width: 40px;
              padding-left: 4px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .column {
              display: flex;
              flex-direction: column;
            }
      
            section {
              margin-top: 6px;
              padding: 6px;
            }
      
            .reason {
              font-size: 12px;
              color: #777;
              margin-top: -8px;
              margin-left: 1px;
              margin-bottom: 12px;
            }
      
            .reason.warn {
              color: #ff3a3a;
            }
      
            .reason.success {
              color: #8aff39;
            }
      
            .tile-spacer {
              height: 80px;
              margin-left: 24px;
              margin-right: 24px;
              border-left: 1px solid #444;
            }
      
            .palette-displays,
            .palette-tile {
              margin-right: 24px;
              border: 2px solid rgba(0, 0, 0, 0);
            }
      
            .palette-tile:hover {
              border: 2px solid rgb(0, 255, 48);
              cursor: pointer;
            }
      
            .selected-display {
              margin-right: 49px;
            }
      
            button {
              cursor: pointer;
            }
      
            #fix-tile {
              width: 80px;
              margin-right: 24px;
            }
          `;
        }
      
      
        template() {
          const valid = this.selected !== undefined ? this.tileData[this.selected].valid : false;
          return html`
            <div class="row">
              <input id="validation-mode-checkbox" type="checkbox" ${this.validationModeChecked_ ? 'checked' : ''}>
              <label style="padding-right: 8px;">Tile validation mode</label>
      
      
              <span style="flex: 1"></span>
              <span class="label">Invalid tiles: </span><span class="value">${this.data ? this.data.invalidTiles.length : ''}</span>
            </div>
      
            <section>
              <div class="sub-header">Selected tile</div>
              <div>
                ${this.selected === undefined ?
                  html`
                    <div class="reason">No tile selected</div>
                  ` :
                  html`
                    <div class="reason warn" style="${!valid ? '' : 'display: none;'}">${this.tileData[this.selected].reason}</div>
                    <div class="reason success" style="${valid ? '' : 'display: none;'}">Valid</div>
                    <div class="row">
                      <palette-display class="selected-display"></palette-display>
      
                      ${this.paletteTool.palettes.map((palette, i) => html`
                        <palette-display class="palette-displays"></palette-display>
                      `).join('\n')}
                    </div>
                    <div class="row">
                      <canvas id="selected-tile-canvas" width="${this.tileDisplayWidth}" height="${this.tileDisplayHeight}"></canvas>
                      <div class="tile-spacer"></div>
                      ${this.paletteTool.palettes.map((palette, i) => html`
                        <canvas id="palette-tile-canvas-${i}" class="palette-tile" width="${this.tileDisplayWidth}" height="${this.tileDisplayHeight}"></canvas>
                      `).join('\n')}
                      <button id="fix-tile">Fix tile</button>
                      <button id="apply-changes">Apply change</button>
                    </div>
                  `
                }
              </div>
            </section>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','palette-display--template');
          t.innerHTML=`
          <style>
            .container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        width: 80px;
      }
      
      .color {
        width: 20px;
        height: 20px;
      }
          </style>
          <render-block>
            <div class="container">
      
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("palette-display", class extends HTMLElementExtended {
        constructor() {
          super("palette-display");
          this.width = this.getAttribute('color-width') || 80;
          this.colorWidth = this.getAttribute('color-width') || 20;
          this.cloneTemplate();
        }
      
        get colors() {
          return this.colors_ || [];
        }
      
        set colors(value) {
          this.colors_ = value;
          this.render();
        }
      
        styles() {
          return css`
            .container {
              display: flex;
              flex-direction: row;
              flex-wrap: wrap;
              width: ${this.width}px;
            }
      
            .color {
              width: ${this.colorWidth}px;
              height: 20px;
            }
          `;
        }
      
        template() {
          return html`
            <div class="container">
            ${this.colors.map(rgba => html`
              <div class="color" style="background-color: rgba(${rgba.join(',')})"></div>
            `).join('\n')}
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','save-dialog--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 11;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .container {
        display: inline-block;
        position: relative;
        left: 50%;
        top: 50%;
        width: 360px;
        height: auto;
        transform: translate(-50%, -50%);
      
        background-color: #DDD;
        border: 1px solid #999;
        border-radius: 3px;
        box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                    0 8px 10px 1px rgba(0,0,0,.14),
                    0 3px 14px 2px rgba(0,0,0,.12);
      }
      
      .title {
        font-size: 22px;
        color: #444;
        margin-bottom: 24px;
      }
      
      .sub-title {
        font-size: 20px;
        color: #444;
        margin-bottom: 18px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      .content {
        padding: 24px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .controls {
        margin-top: 24px;
      }
      
      button {
        align-items: center;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
        display: inline-flex;
        font-size: 14px;
        font-weight: 500;
        height: 33px;
        justify-content: center;
        line-height: 32px;
        min-width: 64px;
        outline: none;
        overflow: hidden;
        padding: 0 8px 0 8px;
        position: relative;
        vertical-align: middle;
        margin: 0;
        background-color: white;
      }
      
      button:hover {
        cursor: pointer;
        background-color: #EEE;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="content">
          <div class="title">Save</div>
      
          <label for="fileName">File name: </label>
          <input name="fileName" value="name">
      
          <br/>
      
          <label for="imageType">Image type: </label>
          <select name="filetype" style="margin-top: 6px">
            <option selected value="c">GBDK (c, h)</option>
            <option value="z80">z80 (asssembly)</option>
            <option value="s">s (asssembly)</option>
            <option value="image/png">PNG</option>
            <option value="image/jpg">JPG</option>
            <option value="image/gif">GIF</option>
          </select>
      
          <div style="margin-top: 12px">
            <label for="tileoffset">Tile offset:</label>
            <input type="number" name="tileoffset" value="0" style="width: 40px">
          </div>
      
          <div style="margin-top: 6px">
            <label for="paletteoffset">Palette offset:</label>
            <input type="number" name="paletteoffset" value="0" style="width: 40px">
          </div>
      
          <div style="margin-top: 6px">
            <label for="includemap">include map:</label>
            <input type="checkbox" name="includemap" checked>
          </div>
      
          <div style="margin-top: 6px">
            <label for="includepalette">include palette:</label>
            <input type="checkbox" name="includepalette" checked>
          </div>
      
          <div class="controls">
            <button id="save-button">save</button>
            <button id="cancel-button">cancel</button>
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("save-dialog", class extends HTMLElementExtended {
        constructor() {
          super("save-dialog");
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.bound_save = this.save.bind(this);
          this.bound_cancel = this.cancel.bind(this);
          this.saveButton.addEventListener('click', this.bound_save);
          this.cancelButton.addEventListener('click', this.bound_cancel);
        }
      
        disconnectedCallback() {
          this.saveButton.removeEventListener('click', this.bound_save);
          this.cancelButton.removeEventListener('click', this.bound_cancel);
        }
      
        get saveButton() {
          return this.shadowRoot.querySelector('#save-button');
        }
      
        get cancelButton() {
          return this.shadowRoot.querySelector('#cancel-button');
        }
      
        get filetype() {
          return this.shadowRoot.querySelector('select[name="filetype"]').value;
        }
      
        get extension() {
          return this.filetype && this.filetype.split('/')[1].toLowerCase();
        }
      
        get fileName() {
          return `${this.shadowRoot.querySelector('input[name="fileName"]').value.split('.')[0]}`;
        }
      
        get canvas() {
          return this.canvas_;
        }
        set canvas(value) {
          this.canvas_ = value;
        }
      
        get paletteTool() {
          return this.paletteTool_;
        }
        set paletteTool(value) {
          this.paletteTool_ = value;
        }
      
        get tileOffset() {
          return this.shadowRoot.querySelector('input[name="tileoffset"]').value;
        }
      
        get paletteOffset() {
          return this.shadowRoot.querySelector('input[name="paletteoffset"]').value;
        }
      
        get includeMap() {
          return this.shadowRoot.querySelector('input[name="includemap"]').checked;
        }
      
        get includePalette() {
          return this.shadowRoot.querySelector('input[name="includepalette"]').checked;
        }
      
        getDataBlob(data, contentType = 'application/octet-stream') {
          data = btoa(data);
          return `data:${contentType};base64,${data}`;
        }
      
        save() {
          try {
            this.downloadFile();
            this.dispatchEvent(new CustomEvent('save', {
              detail: {
                fileName: this.fileName,
                filetype: this.filetype,
                tileOffset: this.tileOffset,
                paletteOffset: this.paletteOffset,
                includeMap: this.includeMap,
                includePalette: this.includePalette
              }
            }));
            this.remove();
          } catch (e) {console.error(e)}
        }
      
        cancel() {
          this.remove();
        }
      
        downloadFile() {
          if (['imge/gif', 'image/jpg', 'image/png'].includes(this.filetype)) {
            // NOTE https://github.com/mattburns/exiftool.js/
            const link = document.createElement('a');
            link.download = this.fileName;
            link.href = document.querySelector('draw-canvas').getDownloadDataURL(this.filetype);
            link.click();
      
          // GBDK files
          }
      
          if (this.filetype === 'c') {
            const cl = new CanvasToGameboyC(this.canvas, this.paletteTool);
            const {
              cFile,
              hFile
            } = cl.format(this.fileName, this.fileName.replace(/-/g, ''), this.tileOffset, this.paletteOffset, this.includeMap, this.includePalette);
      
            const link = document.createElement('a');
            link.download = `${this.fileName}.c`;
            link.href = this.getDataBlob(cFile);
            link.click();
      
            const link2 = document.createElement('a');
            link2.download = `${this.fileName}.h`;
            link2.href = this.getDataBlob(hFile);
            link2.click();
          }
      
          if (this.filetype === 'z80') {
            const cl = new CanvasToGameboyZ80(this.canvas, this.paletteTool);
            const {
              zFile,
              hFile
            } = cl.format(this.fileName, this.fileName.replace(/-/g, ''), this.tileOffset, this.paletteOffset, this.includeMap, this.includePalette);
      
            const link2 = document.createElement('a');
            link2.download = `${this.fileName}.z80`;
            link2.href = this.getDataBlob(zFile);
            link2.click();
      
            const link4 = document.createElement('a');
            link4.download = `${this.fileName}.h`;
            link4.href = this.getDataBlob(hFile);
            link4.click();
          }
      
          if (this.filetype === 's') {
            const cl = new CanvasToGameboyS(this.canvas, this.paletteTool);
            const {
              sFile,
              hFile
            } = cl.format(this.fileName, this.fileName.replace(/-/g, ''), this.tileOffset, this.paletteOffset, this.includeMap, this.includePalette);
      
            const link2 = document.createElement('a');
            link2.download = `${this.fileName}.s`;
            link2.href = this.getDataBlob(sFile);
            link2.click();
      
            const link4 = document.createElement('a');
            link4.download = `${this.fileName}.h`;
            link4.href = this.getDataBlob(hFile);
            link4.click();
          }
        }
      
        styles() {
          return css`
            :host {
              display: block;
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              z-index: 11;
              background-color: rgba(0, 0, 0, 0.5);
            }
      
            .container {
              display: inline-block;
              position: relative;
              left: 50%;
              top: 50%;
              width: 360px;
              height: auto;
              transform: translate(-50%, -50%);
      
              background-color: #DDD;
              border: 1px solid #999;
              border-radius: 3px;
              box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                          0 8px 10px 1px rgba(0,0,0,.14),
                          0 3px 14px 2px rgba(0,0,0,.12);
            }
      
            .title {
              font-size: 22px;
              color: #444;
              margin-bottom: 24px;
            }
      
            .sub-title {
              font-size: 20px;
              color: #444;
              margin-bottom: 18px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            .content {
              padding: 24px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .controls {
              margin-top: 24px;
            }
      
            button {
              align-items: center;
              border: none;
              border-radius: 4px;
              box-sizing: border-box;
              display: inline-flex;
              font-size: 14px;
              font-weight: 500;
              height: 33px;
              justify-content: center;
              line-height: 32px;
              min-width: 64px;
              outline: none;
              overflow: hidden;
              padding: 0 8px 0 8px;
              position: relative;
              vertical-align: middle;
              margin: 0;
              background-color: white;
            }
      
            button:hover {
              cursor: pointer;
              background-color: #EEE;
            }
          `;
        }
      
      
        template() {
          return html`
            <div class="container">
              <div class="content">
                <div class="title">Save</div>
      
                <label for="fileName">File name: </label>
                <input name="fileName" value="name">
      
                <br/>
      
                <label for="imageType">Image type: </label>
                <select name="filetype" style="margin-top: 6px">
                  <option selected value="c">GBDK (c, h)</option>
                  <option value="z80">z80 (asssembly)</option>
                  <option value="s">s (asssembly)</option>
                  <option value="image/png">PNG</option>
                  <option value="image/jpg">JPG</option>
                  <option value="image/gif">GIF</option>
                </select>
      
                <div style="margin-top: 12px">
                  <label for="tileoffset">Tile offset:</label>
                  <input type="number" name="tileoffset" value="0" style="width: 40px">
                </div>
      
                <div style="margin-top: 6px">
                  <label for="paletteoffset">Palette offset:</label>
                  <input type="number" name="paletteoffset" value="0" style="width: 40px">
                </div>
      
                <div style="margin-top: 6px">
                  <label for="includemap">include map:</label>
                  <input type="checkbox" name="includemap" checked>
                </div>
      
                <div style="margin-top: 6px">
                  <label for="includepalette">include palette:</label>
                  <input type="checkbox" name="includepalette" checked>
                </div>
      
                <div class="controls">
                  <button id="save-button">save</button>
                  <button id="cancel-button">cancel</button>
                </div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','upload-dialog--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 11;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .container {
        display: inline-block;
        position: relative;
        left: 50%;
        top: 50%;
        width: 360px;
        height: auto;
        transform: translate(-50%, -50%);
      
        background-color: #DDD;
        border: 1px solid #999;
        border-radius: 3px;
        box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                    0 8px 10px 1px rgba(0,0,0,.14),
                    0 3px 14px 2px rgba(0,0,0,.12);
      }
      
      .title {
        font-size: 22px;
        color: #444;
        margin-bottom: 24px;
      }
      
      .sub-title {
        font-size: 20px;
        color: #444;
        margin-bottom: 18px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      .content {
        padding: 24px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .controls {
        margin-top: 24px;
      }
      
      .button,
      button {
        align-items: center;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
        display: inline-flex;
        font-size: 14px;
        font-weight: 500;
        height: 33px;
        justify-content: center;
        line-height: 32px;
        min-width: 64px;
        outline: none;
        overflow: hidden;
        padding: 0 8px 0 8px;
        position: relative;
        vertical-align: middle;
        margin: 0;
        background-color: white;
      }
      
      .button:hover,
      button:hover {
        cursor: pointer;
        background-color: #EEE;
      }
      
      #ok {
        margin-right: 6px;
      }
      
      #image-container {
          margin-top: 18px;
      }
      
      #image-container img {
        max-width: 400px;
        height: auto;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="content">
          <div class="title">Upload</div>
      
          <div>
            <label id="browser" class="button" for="fileChooser">Browse</label>
            <input hidden="true" type="file" name="fileChooser" id="fileChooser" accept="image/jpeg,image/png">
          </div>
      
          <div id="image-container">
            <div id="size"></div>
            <img></img>
          </div>
      
          <div class="row">
            <button id="ok">OK</button>
            <button id="cancel">Cancel</button>
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("upload-dialog", class extends HTMLElementExtended {
        constructor() {
          super("upload-dialog");
      
          this.bound_loadImage = this.loadImage.bind(this);
          this.bound_ok = this.ok.bind(this);
          this.bound_cancel = this.cancel.bind(this);
      
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.shadowRoot.querySelector('input[type=file]').addEventListener('change', this.bound_loadImage);
          this.shadowRoot.querySelector('#ok').addEventListener('click', this.bound_ok);
          this.shadowRoot.querySelector('#cancel').addEventListener('click', this.bound_cancel);
        }
      
        disconnectedCallback() {
          this.shadowRoot.querySelector('input[type=file]').removeEventListener('change', this.bound_loadImage);
          this.shadowRoot.querySelector('#ok').removeEventListener('click', this.bound_ok);
          this.shadowRoot.querySelector('#cancel').removeEventListener('click', this.bound_cancel);
        }
      
        get displayCanvas() {
          return this.shadowRoot.querySelector('#display-canvas');
        }
      
        get canvas() {
          return this.canvas_;
        }
      
        set canvas(value) {
          this.canvas_ = value;
        }
      
        get image() {
          return this.shadowRoot.querySelector('img');
        }
      
        set size(value) {
          return this.shadowRoot.querySelector('#size').innerText = value;
        }
      
        loadImage(e) {
          if(e.target.files.length === 0) return;
          const file = e.target.files[0];
          if(file.type !== '' && !file.type.match('image.*')) return;
      
          this.image.addEventListener('load', () => {
            this.hasImage = true;
            // TODO display actual size. this is css max width
            this.size = `${this.image.width} x ${this.image.height}`;
          }, false);
          this.image.src = window.URL.createObjectURL(file);
        }
      
        ok() {
          if (this.hasImage) this.canvas.drawImage(this.image, 0, 0);
          this.remove();
        }
      
        cancel() {
          this.remove();
        }
      
        styles() {
          return css`
            :host {
              display: block;
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              z-index: 11;
              background-color: rgba(0, 0, 0, 0.5);
            }
      
            .container {
              display: inline-block;
              position: relative;
              left: 50%;
              top: 50%;
              width: 360px;
              height: auto;
              transform: translate(-50%, -50%);
      
              background-color: #DDD;
              border: 1px solid #999;
              border-radius: 3px;
              box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                          0 8px 10px 1px rgba(0,0,0,.14),
                          0 3px 14px 2px rgba(0,0,0,.12);
            }
      
            .title {
              font-size: 22px;
              color: #444;
              margin-bottom: 24px;
            }
      
            .sub-title {
              font-size: 20px;
              color: #444;
              margin-bottom: 18px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            .content {
              padding: 24px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .controls {
              margin-top: 24px;
            }
      
            .button,
            button {
              align-items: center;
              border: none;
              border-radius: 4px;
              box-sizing: border-box;
              display: inline-flex;
              font-size: 14px;
              font-weight: 500;
              height: 33px;
              justify-content: center;
              line-height: 32px;
              min-width: 64px;
              outline: none;
              overflow: hidden;
              padding: 0 8px 0 8px;
              position: relative;
              vertical-align: middle;
              margin: 0;
              background-color: white;
            }
      
            .button:hover,
            button:hover {
              cursor: pointer;
              background-color: #EEE;
            }
      
            #ok {
              margin-right: 6px;
            }
      
            #image-container {
                margin-top: 18px;
            }
      
            #image-container img {
              max-width: 400px;
              height: auto;
            }
          `;
        }
      
      
        template() {
          return html`
            <div class="container">
              <div class="content">
                <div class="title">Upload</div>
      
                <div>
                  <label id="browser" class="button" for="fileChooser">Browse</label>
                  <input hidden="true" type="file" name="fileChooser" id="fileChooser" accept="image/jpeg,image/png">
                </div>
      
                <div id="image-container">
                  <div id="size"></div>
                  <img></img>
                </div>
      
                <div class="row">
                  <button id="ok">OK</button>
                  <button id="cancel">Cancel</button>
                </div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','tile-palette-fixer--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 11;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .container {
        display: inline-block;
        position: relative;
        left: 50%;
        top: 50%;
        width: 360px;
        height: auto;
        transform: translate(-50%, -50%);
      
        background-color: #DDD;
        border: 1px solid #999;
        border-radius: 3px;
        box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                    0 8px 10px 1px rgba(0,0,0,.14),
                    0 3px 14px 2px rgba(0,0,0,.12);
      }
      
      .title {
        font-size: 22px;
        color: #444;
        margin-bottom: 24px;
      }
      
      .sub-title {
        font-size: 20px;
        color: #444;
        margin-bottom: 18px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      .content {
        padding: 24px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .column {
        display: flex;
        flex-direction: column;
      }
      
      .wrap {
        flex-wrap: wrap;
      }
      
      .controls {
        margin-top: 24px;
      }
      
      .button,
      button {
        align-items: center;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
        display: inline-flex;
        font-size: 14px;
        font-weight: 500;
        height: 33px;
        justify-content: center;
        line-height: 32px;
        min-width: 64px;
        outline: none;
        overflow: hidden;
        padding: 0 8px 0 8px;
        position: relative;
        vertical-align: middle;
        margin: 0;
        background-color: white;
      }
      
      .button:hover,
      button:hover {
        cursor: pointer;
        background-color: #EEE;
      }
      
      #ok,
      #all {
        margin-right: 6px;
      }
      
      .colors-container {
        margin-left: 22px;
      }
      
      .color-block {
        width: 24px;
        height: 24px;
        border: 2px solid rgba(53, 133, 185, 0);
      }
      
      .colors-container .color-block {
        margin-bottom: 5px;
        cursor: pointer;
      }
      
      .conversion-container,
      .palette-container {
        margin-left: 10px;
      }
      
      .conversion-container .color-block,
      .palette-container .color-block {
        margin-bottom: 5px;
        cursor: pointer;
      }
      
      .conversion-container .color-block.selected,
      .palette-container .color-block.selected {
        border: 2px solid rgb(53, 133, 185);
      }
      
      .conversion-container .color-block:not(.selected):hover,
      .palette-container .color-block:not(.selected):hover {
        border: 2px solid rgb(53, 133, 185, 0.5);
      }
      
      .all-colors-container {
        margin: 24px 0;
      }
      
      .all-colors-container .color-block {
        margin: 4px;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="content">
          <div class="title">Fix Tile Palette</div>
      
          <div class="column">
            <div class="row">
              <div id="canvas-container">
                <canvas id="canvas" width="160" height="160"></canvas>
              </div>
      
              <div class="colors-container column">
                
              </div>
      
              <div class="conversion-container column">
                
              </div>
            </div>
      
            <div>
              <div class="all-colors-container row wrap">
                
              </div>
            </div>
          </div>
      
          <div class="row">
            <button id="ok">Update</button>
            <button id="all">Update All</button>
            <button id="cancel">Cancel</button>
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("tile-palette-fixer", class extends HTMLElementExtended {
        constructor() {
          super("tile-palette-fixer");
      
          this.colors = [];
          this.colorConversions = [];
          this.palette = [];
          this.scale = 20;
          this.tileWidth_ = parseInt(this.getAttribute('tile-width') || 8);
          this.tileHeight_ = parseInt(this.getAttribute('tile-height') || 8);
          this.bound_ok = this.ok.bind(this);
          this.bound_fixAll = this.fixAll.bind(this);
          this.bound_cancel = this.cancel.bind(this);
          this.bound_conversionClick = this.conversionClick.bind(this);
          this.bound_colorClick = this.colorClick.bind(this);
      
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.addEvents()
        }
      
        disconnectedCallback() {
          this.removeEvents();
        }
      
        beforeEvents() {
          this.addEvents();
        }
      
        afterRender() {
          this.addEvents();
        }
      
        addEvents() {
          this.shadowRoot.querySelector('#ok').addEventListener('click', this.bound_ok);
          this.shadowRoot.querySelector('#all').addEventListener('click', this.bound_fixAll);
          this.shadowRoot.querySelector('#cancel').addEventListener('click', this.bound_cancel);
          this.shadowRoot.querySelector('.conversion-container').addEventListener('click', this.bound_conversionClick);
          this.shadowRoot.querySelector('.colors-container').addEventListener('click', this.bound_colorClick);
          this.shadowRoot.querySelector('.all-colors-container').addEventListener('click', this.bound_colorClick);
        }
      
        removeEvents() {
          this.shadowRoot.querySelector('#ok').removeEventListener('click', this.bound_ok);
          this.shadowRoot.querySelector('#all').removeEventListener('click', this.bound_fixAll);
          this.shadowRoot.querySelector('#cancel').removeEventListener('click', this.bound_cancel);
          this.shadowRoot.querySelector('.conversion-container').removeEventListener('click', this.bound_conversionClick);
          this.shadowRoot.querySelector('.colors-container').removeEventListener('click', this.bound_colorClick);
          this.shadowRoot.querySelector('.all-colors-container').removeEventListener('click', this.bound_colorClick);
        }
      
        get tileWidth() {
          return this.tileWidth_;
        }
      
        get tileHeight() {
          return this.tileHeight_;
        }
      
        get canvas() {
          return this.shadowRoot.querySelector('#canvas');
        }
      
        get tileData() {
          return this.tileData_;
        }
      
        get drawCanvas() {
          return this.drawCanvas_;
        }
      
        set drawCanvas(value) {
          this.drawCanvas_ = value;
        }
      
        set tileData(value) {
          this.tileData_ = value;
          this.getColors();
          this.render();
          this.drawTile(value);
        }
      
        get allColors() {
          return this.allColors_ || [];
        }
      
        set allColors(value) {
          this.allColors_ = value;
        }
      
        get selected() {
          return this.selected_;
        }
      
        set selected(value) {
          this.selected_ = value;
        }
      
        setData(selected, tileData, paletteColors, drawCanvas) {
          this.selected = selected;
          this.allColors = paletteColors;
          this.tileData = tileData;
          this.drawCanvas = drawCanvas;
        }
      
        getColors() {
          const data = this.tileData;
          const pixelScale = this.scale;
          const pixelsX = this.tileWidth;
          const pixelsY = this.tileHeight;
          let x;
          let y = 0;
      
          this.colors = {};
          for(; y < pixelsY; y += 1) {
            for(x = 0; x < pixelsX; x += 1) {
              this.colors[ColorUtils.RGBAtoInt(data[y * pixelsX + x])] = data[y * pixelsX + x];
            }
          }
          this.colors = Object.keys(this.colors).map(k => this.colors[k]);
          this.palette = this.colors.map(c => c).slice(0, 4);
        }
      
        drawTile() {
          const data = this.tileData;
          const pixelScale = this.scale;
          const pixelsX = this.tileWidth;
          const pixelsY = this.tileHeight;
          const ctx = this.canvas.getContext('2d');
          const intColors = this.colors.map(ColorUtils.RGBAtoInt);
          let x;
          let y = 0;
          let color;
          let colorPosition;
          this.convertedTileData = [];
      
          for(; y < pixelsY; y += 1) {
            for(x = 0; x < pixelsX; x += 1) {
              color = data[y * pixelsX + x];
              colorPosition = intColors.indexOf(ColorUtils.RGBAtoInt(data[y * pixelsX + x]));
              if (this.colorConversions[colorPosition]) color = this.colorConversions[colorPosition];
              ctx.fillStyle = `rgba(${color})`;
              ctx.fillRect(x * pixelScale, y * pixelScale, pixelScale, pixelScale);
              this.convertedTileData.push(color);
            }
          }
        }
      
        compareColors(a, b) {
          return ColorUtils.RGBAtoInt(a) === ColorUtils.RGBAtoInt(b);
        }
      
        conversionClick(e) {
          if (this.selectedPaletteColor) this.selectedPaletteColor.classList.remove('selected');
          if (this.selectedConversionColor) this.selectedConversionColor.classList.remove('selected');
          this.selectedPaletteColor = undefined;
          this.selectedConversionColor = e.target;
          this.selectedConversionColor.classList.add('selected');
        }
      
        colorClick(e) {
          if (this.selectedConversionColor) {
            this.selectedConversionColor.style.backgroundColor = e.target.style.backgroundColor;
            this.colorConversions[parseInt(this.selectedConversionColor.getAttribute('location'))] = [...e.target.style.backgroundColor.replace('rgb(', '').replace(')', '').split(',').map(i => parseInt(i)), 1];
            this.drawTile();
          }
      
          if (this.selectedPaletteColor) {
            this.selectedPaletteColor.style.backgroundColor = e.target.style.backgroundColor;
            this.palette[parseInt(this.selectedPaletteColor.getAttribute('location'))] = [...e.target.style.backgroundColor.replace('rgb(', '').replace(')', '').split(',').map(i => parseInt(i)), 1];
          }
        }
      
        ok() {
          this.drawCanvas.drawTile(this.selected, this.convertedTileData);
          this.dispatchChange();
          this.remove();
        }
      
        fixAll() {
          const originalColors = this.colors.reduce((a, c, i) => {
            a[ColorUtils.RGBAtoInt(c)] = this.colorConversions[i] || this.colors[i];
            return a;
          }, {})
          this.drawCanvas.remapTilesPalette(originalColors);
          this.dispatchChange();
          this.remove();
        }
      
        cancel() {
          this.remove();
        }
      
        dispatchChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {}
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              z-index: 11;
              background-color: rgba(0, 0, 0, 0.5);
            }
      
            .container {
              display: inline-block;
              position: relative;
              left: 50%;
              top: 50%;
              width: 360px;
              height: auto;
              transform: translate(-50%, -50%);
      
              background-color: #DDD;
              border: 1px solid #999;
              border-radius: 3px;
              box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                          0 8px 10px 1px rgba(0,0,0,.14),
                          0 3px 14px 2px rgba(0,0,0,.12);
            }
      
            .title {
              font-size: 22px;
              color: #444;
              margin-bottom: 24px;
            }
      
            .sub-title {
              font-size: 20px;
              color: #444;
              margin-bottom: 18px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            .content {
              padding: 24px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .column {
              display: flex;
              flex-direction: column;
            }
      
            .wrap {
              flex-wrap: wrap;
            }
      
            .controls {
              margin-top: 24px;
            }
      
            .button,
            button {
              align-items: center;
              border: none;
              border-radius: 4px;
              box-sizing: border-box;
              display: inline-flex;
              font-size: 14px;
              font-weight: 500;
              height: 33px;
              justify-content: center;
              line-height: 32px;
              min-width: 64px;
              outline: none;
              overflow: hidden;
              padding: 0 8px 0 8px;
              position: relative;
              vertical-align: middle;
              margin: 0;
              background-color: white;
            }
      
            .button:hover,
            button:hover {
              cursor: pointer;
              background-color: #EEE;
            }
      
            #ok,
            #all {
              margin-right: 6px;
            }
      
            .colors-container {
              margin-left: 22px;
            }
      
            .color-block {
              width: 24px;
              height: 24px;
              border: 2px solid rgba(53, 133, 185, 0);
            }
      
            .colors-container .color-block {
              margin-bottom: 5px;
              cursor: pointer;
            }
      
            .conversion-container,
            .palette-container {
              margin-left: 10px;
            }
      
            .conversion-container .color-block,
            .palette-container .color-block {
              margin-bottom: 5px;
              cursor: pointer;
            }
      
            .conversion-container .color-block.selected,
            .palette-container .color-block.selected {
              border: 2px solid rgb(53, 133, 185);
            }
      
            .conversion-container .color-block:not(.selected):hover,
            .palette-container .color-block:not(.selected):hover {
              border: 2px solid rgb(53, 133, 185, 0.5);
            }
      
            .all-colors-container {
              margin: 24px 0;
            }
      
            .all-colors-container .color-block {
              margin: 4px;
            }
          `;
        }
      
      
        template() {
          return html`
            <div class="container">
              <div class="content">
                <div class="title">Fix Tile Palette</div>
      
                <div class="column">
                  <div class="row">
                    <div id="canvas-container">
                      <canvas id="canvas" width="${this.tileWidth * this.scale}" height="${this.tileHeight * this.scale}"></canvas>
                    </div>
      
                    <div class="colors-container column">
                      ${this.colors.map((c, i) => {
                          return `<div class="color-block" style="background-color: rgba(${c})" location="${i}"></div>`;
                        }).join('\n')}
                    </div>
      
                    <div class="conversion-container column">
                      ${this.colors.map((c, i) => {
                          return `<div class="color-block" style="background-color: rgba(${this.colorConversions[i] || c})" location="${i}"></div>`;
                        }).join('\n')}
                    </div>
                  </div>
      
                  <div>
                    <div class="all-colors-container row wrap">
                      ${this.allColors.map((c, i) => {
                          return `<div class="color-block" style="background-color: rgba(${c})" location="${i}"></div>`;
                        }).join('\n')}
                    </div>
                  </div>
                </div>
      
                <div class="row">
                  <button id="ok">Update</button>
                  <button id="all">Update All</button>
                  <button id="cancel">Cancel</button>
                </div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','palette-mapper--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 11;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .container {
        display: inline-block;
        position: relative;
        left: 50%;
        top: 50%;
        width: 360px;
        height: auto;
        transform: translate(-50%, -50%);
      
        background-color: #DDD;
        border: 1px solid #999;
        border-radius: 3px;
        box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                    0 8px 10px 1px rgba(0,0,0,.14),
                    0 3px 14px 2px rgba(0,0,0,.12);
      }
      
      .title {
        font-size: 22px;
        color: #444;
        margin-bottom: 24px;
      }
      
      .sub-title {
        font-size: 20px;
        color: #444;
        margin-bottom: 18px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      .title + .sub-header {
        margin-top: -28px;
        margin-bottom: 28px;
      }
      
      .content {
        padding: 24px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .column {
        display: flex;
        flex-direction: column;
      }
      
      .wrap {
        flex-wrap: wrap;
      }
      
      .controls {
        margin-top: 24px;
      }
      
      .button,
      button {
        align-items: center;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
        display: inline-flex;
        font-size: 14px;
        font-weight: 500;
        height: 33px;
        justify-content: center;
        line-height: 32px;
        min-width: 64px;
        outline: none;
        overflow: hidden;
        padding: 0 8px 0 8px;
        position: relative;
        vertical-align: middle;
        margin: 0;
        background-color: white;
      }
      
      .button:hover,
      button:hover {
        cursor: pointer;
        background-color: #EEE;
      }
      
      #ok,
      #all {
        margin-right: 6px;
      }
      
      .colors-container {
        margin-left: 22px;
      }
      
      .color-block {
        width: 24px;
        height: 24px;
        border: 2px solid rgba(53, 133, 185, 0);
      }
      
      .color-block[is-picked="true"] {
        opacity: 0;
      }
      
      .floating-color-block {
        position: fixed;
        top: 0;
        left: 0;
        opacity: 0;
        user-select: none;
        pointer-events: none;
        width: 24px;
        height: 24px;
        border: 2px solid rgba(53, 133, 185, 0);
      }
      
      .column.spaced-end {
        align-items: flex-end;
        justify-content: space-between;
      }
      
      .palette-container {
        display: flex;
        flex: 1;
        margin-left: 24px;
        border-left: 1px solid #666;
      }
      
      .horizontal-divider {
        width: 100%;
        border-bottom: 2px solid #999;
      }
      
      .palette-color-constainer {
        width: 100%;
        flex: 1;
        display: flex;
        flex-direction: column;
        border: 1px solid #999;
      }
      
      .picked-colors-container {
        display: flex;
        flex: 1;
        background-color: #DDD;
      }
      
      .palette-color-selected {
        border: 3px solid rgb(20, 186, 247);
        box-sizing: border-box;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="content">
          <div id="floating-color-block" class="floating-color-block"></div>
          <div class="title">Sort colors</div>
          <div class="sub-header">Click and drag color across, Click on paletts color to change</div>
      
          <div class="row">
      
            <!-- all colors -->
            <div class="column" style="padding-right: 24px;">
              <div class="colors-container column">
                
              </div>
            </div>
      
            <!-- palettes -->
            <div class="palette-container">
              
            </div>
          </div>
      
          <div class="row" style="margin-top: 24px;">
            <div class="row">
              <label for="store">store: </label>
              <input type="checkbox" name="store">
            </div>
            <span style="flex: 1;"></span>
            <button id="ok">ok</button>
            <button id="cancel">Cancel</button>
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("palette-mapper", class extends HTMLElementExtended {
        constructor() {
          super("palette-mapper");
          this.settings = new Settings();
          this.colors = [];
          this.palettes = [];
          this.bound_ok = this.ok.bind(this);
          this.bound_cancel = this.cancel.bind(this);
          this.bound_mouseDown = this.mouseDown.bind(this);
          this.bound_mouseUp = this.mouseUp.bind(this);
          this.bound_mouseMove = this.mouseMove.bind(this);
          this.bound_mouseOver = this.mouseOver.bind(this);
          this.bound_mouseOut = this.mouseOut.bind(this);
          this.bound_paletteColorClock = this.paletteColorClick.bind(this);
          this.cloneTemplate();
        }
      
        connectedCallback() {
          this.canvasUtils = new CanvasUtils();
          this.colors = this.canvasUtils.canvasColors().reverse();
          this.palettes = this.canvasUtils.palettes;
          this.render();
      
          this.checkStoredForMatch();
        }
      
        disconnectedCallback() {
          this.removeEvents();
        }
      
        afterRender() {
          this.addEvents();
        }
      
        beforeRender() {
          this.removeEvents();
        }
      
        addEvents() {
          this.shadowRoot.addEventListener('mousedown', this.bound_mouseDown);
          this.shadowRoot.querySelector('#ok').addEventListener('click', this.bound_ok);
          this.shadowRoot.querySelector('#cancel').addEventListener('click', this.bound_cancel);
          this.shadowRoot.addEventListener('click', this.bound_paletteColorClock);
        }
      
        removeEvents() {
          this.shadowRoot.removeEventListener('mousedown', this.bound_mouseDown);
          document.removeEventListener('mouseup', this.bound_mouseUp);
          document.removeEventListener('mousemove', this.bound_mouseMove);
          this.shadowRoot.querySelector('#ok').removeEventListener('click', this.bound_ok);
          this.shadowRoot.querySelector('#cancel').removeEventListener('click', this.bound_cancel);
          this.shadowRoot.querySelectorAll('[container-location]').forEach(el => {
            el.removeEventListener('mouseenter', this.bound_mouseOver);
            el.removeEventListener('mouseleave', this.bound_mouseOut);
          });
          this.shadowRoot.removeEventListener('click', this.bound_paletteColorClock);
        }
      
        checkStoredForMatch() {
          const stored = this.settings.colorMaps;
          const foundIndex = stored.findIndex(({ map: { originalColors, originalPalettes } }) => {
            if (!this.compareArrOfColors(this.colors, originalColors)) return false;
            // TODO do i need to verify the original palettes
            return true;
          });
          if (foundIndex > -1) {
            const found = stored[foundIndex];
            const combinedMap = {};
            const palettesColors = found.map.colorMap.reduce((a, b) => {
              const keys = Object.keys(b);
              keys.forEach(key => {
                if (!combinedMap[key]) combinedMap[key] = [];
                combinedMap[key] = combinedMap[key].concat(b[key]);
              });
              return a.concat(keys);
            }, []);
      
            [...this.shadowRoot.querySelectorAll('.colors')].forEach(el => el.style.opacity = 0);
            [...this.shadowRoot.querySelectorAll('.palette-color')].forEach((el, i) => {
              el.style.backgroundColor = palettesColors[i];
              combinedMap[palettesColors[i]].forEach(color => {
                let rgba = color.replace('rgb(', '').replace(')', '').replace(/\s/g, '').split(',');
                rgba.push('1');
                rgba = `rgba(${rgba.join(',')})`;
                this.injectColorIntoContainer(el.parentNode.parentNode.querySelector('.picked-colors-container'), color, this.colors.indexOf(rgba));
              });
            });
          }
        }
      
        compareArrOfColors(a, b) {
          if (a.length !== b.length) return false;
      
          const length = a.length;
          let i = 0;
      
          for(; i < length; i += 1) {
            if (a[i] !== b[i]) return false;
          }
      
          return true;
        }
      
        paletteColorClick(e) {
          if (this.allowColorSelect && e.target.classList.contains('color-block')) {
            this.slectedPaletteColor.style.backgroundColor = e.target.style.backgroundColor;
          }
      
          if (this.slectedPaletteColor) {
            this.slectedPaletteColor.classList.remove('palette-color-selected');
            this.slectedPaletteColor = undefined;
            this.allowColorSelect = false;
          } else if (e.target.classList.contains('palette-color')) {
            e.target.classList.add('palette-color-selected');
            this.slectedPaletteColor = e.target;
            this.allowColorSelect = true;
          }
        }
      
        mouseDown(e) {
          if (e.target.hasAttribute('is-picked') && e.target.getAttribute('is-picked') === 'false') {
            document.addEventListener('mouseup', this.bound_mouseUp);
            document.addEventListener('mousemove', this.bound_mouseMove);
            this.shadowRoot.querySelectorAll('[container-location]').forEach(el => {
              el.addEventListener('mouseenter', this.bound_mouseOver);
              el.addEventListener('mouseleave', this.bound_mouseOut);
            });
            this.currentLocationContainerElement = undefined;
            const { left, top} = this.shadowRoot.querySelector('.container').getBoundingClientRect();
            const el = this.shadowRoot.querySelector('#floating-color-block');
            el.setAttribute('color-id', e.target.getAttribute('color-id'));
            el.style.backgroundColor = e.target.style.backgroundColor;
            el.style.left = `${e.clientX - left}px`;
            el.style.top = `${e.clientY - top}px`;
            el.style.opacity = '1';
          }
        }
      
        mouseUp(e) {
          this.shadowRoot.querySelectorAll('[container-location]').forEach(el => {
            el.removeEventListener('mouseenter', this.bound_mouseOver);
            el.removeEventListener('mouseleave', this.bound_mouseOut);
          });
          document.removeEventListener('mouseup', this.bound_mouseUp);
          document.removeEventListener('mousemove', this.bound_mouseMove);
          const el = this.shadowRoot.querySelector('#floating-color-block');
          el.style.opacity = '0';
      
          if (this.currentLocationContainerElement) this.injectColorIntoContainer(this.currentLocationContainerElement, el.style.backgroundColor, el.getAttribute('color-id'));
        }
      
        mouseMove(e) {
          const { left, top} = this.shadowRoot.querySelector('.container').getBoundingClientRect();
          const el = this.shadowRoot.querySelector('#floating-color-block');
          el.style.left = `${e.clientX - left}px`;
          el.style.top = `${e.clientY - top}px`;
        }
      
        mouseOver(e) {
          this.currentLocationContainerElement = e.target;
        }
      
        mouseOut(e) {
          if (e.target === this.currentLocationContainerElement) this.currentLocationContainerElement = undefined;
        }
      
        injectColorIntoContainer(el, color, id) {
          el.insertAdjacentHTML('afterBegin', `<div class="color-block" style="background-color: ${color}" color-id="${id}"></div>`);
          this.shadowRoot.querySelector(`[color-id="${id}"][is-picked="false"]`).setAttribute('is-picked', 'true');
        }
      
        ok() {
          this.dispatchChange();
          this.remove();
        }
      
        cancel() {
          this.remove();
        }
      
        dispatchChange() {
          const colorsPerPallet = 4; // TODO hook this up
          const p = [...this.shadowRoot.querySelectorAll('.palette-color')].map(el => el.style.backgroundColor);
          let palettes = [...new Array(p.length / colorsPerPallet)].map(_ => []);
          const length = p.length;
          let i = 0;
          for (; i < length; i += 1) {
            palettes[Math.floor(i / colorsPerPallet)].push(p[i]);
          }
          const containers = [...this.shadowRoot.querySelectorAll('[container-location]')].reduce((a, b) => {
            const l = b.getAttribute('container-location').split('-');
            if (!a[l[0]]) a[l[0]] = [];
            a[l[0]][l[1]] = [...b.children].map(el => el.style.backgroundColor);
            return a;
          }, []);
          const colorMap = [...new Array(p.length / colorsPerPallet)].map(_ => ({}));
          colorMap.forEach((obj, i) => {
            palettes[i].reduce((a, b, j) => {
              a[b] = containers[i][j];
              return a;
            }, obj)
          });
          if (this.shadowRoot.querySelector('input[type="checkbox"]').checked) {
            this.settings.saveColorMap({
              label: Date.now(),
              map: {
                originalColors: this.colors,
                originalPalettes: palettes,
                colorMap
              }
            });
          }
      
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              palettes,
              colorMap
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              z-index: 11;
              background-color: rgba(0, 0, 0, 0.5);
            }
      
            .container {
              display: inline-block;
              position: relative;
              left: 50%;
              top: 50%;
              width: 360px;
              height: auto;
              transform: translate(-50%, -50%);
      
              background-color: #DDD;
              border: 1px solid #999;
              border-radius: 3px;
              box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                          0 8px 10px 1px rgba(0,0,0,.14),
                          0 3px 14px 2px rgba(0,0,0,.12);
            }
      
            .title {
              font-size: 22px;
              color: #444;
              margin-bottom: 24px;
            }
      
            .sub-title {
              font-size: 20px;
              color: #444;
              margin-bottom: 18px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            .title + .sub-header {
              margin-top: -28px;
              margin-bottom: 28px;
            }
      
            .content {
              padding: 24px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .column {
              display: flex;
              flex-direction: column;
            }
      
            .wrap {
              flex-wrap: wrap;
            }
      
            .controls {
              margin-top: 24px;
            }
      
            .button,
            button {
              align-items: center;
              border: none;
              border-radius: 4px;
              box-sizing: border-box;
              display: inline-flex;
              font-size: 14px;
              font-weight: 500;
              height: 33px;
              justify-content: center;
              line-height: 32px;
              min-width: 64px;
              outline: none;
              overflow: hidden;
              padding: 0 8px 0 8px;
              position: relative;
              vertical-align: middle;
              margin: 0;
              background-color: white;
            }
      
            .button:hover,
            button:hover {
              cursor: pointer;
              background-color: #EEE;
            }
      
            #ok,
            #all {
              margin-right: 6px;
            }
      
            .colors-container {
              margin-left: 22px;
            }
      
            .color-block {
              width: 24px;
              height: 24px;
              border: 2px solid rgba(53, 133, 185, 0);
            }
      
            .color-block[is-picked="true"] {
              opacity: 0;
            }
      
            .floating-color-block {
              position: fixed;
              top: 0;
              left: 0;
              opacity: 0;
              user-select: none;
              pointer-events: none;
              width: 24px;
              height: 24px;
              border: 2px solid rgba(53, 133, 185, 0);
            }
      
            .column.spaced-end {
              align-items: flex-end;
              justify-content: space-between;
            }
      
            .palette-container {
              display: flex;
              flex: 1;
              margin-left: 24px;
              border-left: 1px solid #666;
            }
      
            .horizontal-divider {
              width: 100%;
              border-bottom: 2px solid #999;
            }
      
            .palette-color-constainer {
              width: 100%;
              flex: 1;
              display: flex;
              flex-direction: column;
              border: 1px solid #999;
            }
      
            .picked-colors-container {
              display: flex;
              flex: 1;
              background-color: #DDD;
            }
      
            .palette-color-selected {
              border: 3px solid rgb(20, 186, 247);
              box-sizing: border-box;
            }
          `;
        }
      
        template() {
          return html`
            <div class="container">
              <div class="content">
                <div id="floating-color-block" class="floating-color-block"></div>
                <div class="title">Sort colors</div>
                <div class="sub-header">Click and drag color across, Click on paletts color to change</div>
      
                <div class="row">
      
                  <!-- all colors -->
                  <div class="column" style="padding-right: 24px;">
                    <div class="colors-container column">
                      ${this.colors.map((c, i) => html`
                        <div class="color-block colors" style="background-color: ${c}" color-id="${i}" is-picked="false"></div>
                      `).join('\n')}
                    </div>
                  </div>
      
                  <!-- palettes -->
                  <div class="palette-container">
                    ${this.palettes.map((p, pi) => html`
                      <div class="column spaced-end" style="flex: 1;">
                        ${p.map((c, i) => html`
                          <div class="palette-color-constainer">
                            <div class="row">
                              <div class="color-block palette-color" style="background-color: rgba(${c}); flex: 1;"></div>
                            </div>
                            <div class="picked-colors-container" container-location="${pi}-${i}">
                            </div>
                          </div>
                        `).join('\n')}
                      </div>
                    `).join('\n')}
                  </div>
                </div>
      
                <div class="row" style="margin-top: 24px;">
                  <div class="row">
                    <label for="store">store: </label>
                    <input type="checkbox" name="store">
                  </div>
                  <span style="flex: 1;"></span>
                  <button id="ok">ok</button>
                  <button id="cancel">Cancel</button>
                </div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','settings-tool--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
      }
      
      .divider {
        border-bottom: 1px solid #999;
      }
      
      .spacer {
        padding-top: 12px;
      }
      
      .top-row {
        display: flex;
        align-items: center;
      }
      
      .title {
        font-size: 18px;
        font-weight: 400;
        padding-left: 6px;
        flex: 1;
      }
      
      .subtitle {
        font-size: 14px;
        padding-left: 6px;
        flex: 1;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .settings {
        margin: 18px 0;
      }
      
      .settings .sub {
        margin-top: 6px;
        margin-left: 12px;
      }
      
      .setting-input {
        width: 40px;
        margin-right: 22px;
      }
      
      .palette-container {
        width: 312px;
        margin: 6px;
      }
      
      .palette {
        display: flex;
        flex-direction: row;
        padding: 6px;
      }
      
      .palette label {
        font-size: 14px;
        font-weight: bold;
        color: #666;
        padding-right: 12px;
      }
      
      .palette button {
        margin-left: 6px;
      }
      
      .color {
        flex: 1;
        height: 24px;
        border: 3px solid rgba(0,0,0,0);
        box-sizing: border-box;
      }
          </style>
          <render-block>
            <div class="palette-container">
        <div class="top-row">
          <div class="title">Settings</div>
        </div>
      
        <div class="row">
          <button id="save-current-palette-button">Save current palettes</button>
        </div>
      
        <div class="settings">
          <div class="subtitle">Saved Palettes</div>
      
          <div class="sub">
            
          </div>
        </div>
      
      
        <div class="subtitle" style="margin-top: 48px;">Saved Color maps</div>
        <div>
          <div class="sub">
            
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("settings-tool", class extends HTMLElementExtended {
        constructor() {
          super("settings-tool");
          this.settings = new Settings();
          this.bound_saveCurrentPalettes = this.saveCurrentPalettes.bind(this);
          this.bound_clearPalette = this.clearPalette.bind(this);
          this.bound_clearMap = this.clearMap.bind(this);
          this.bound_loadPalette = this.loadPalette.bind(this);
          this.bound_render = this.render.bind(this);
          this.cloneTemplate(true);
        }
      
        connectedCallback() {
          this.addEvents();
        }
      
        disconnectedCallback() {
          this.removeEvents();
        }
      
        addEvents() {
          this.shadowRoot.querySelector('#save-current-palette-button').addEventListener('click', this.bound_saveCurrentPalettes);
          [...this.shadowRoot.querySelectorAll('.clear-palette-button')].forEach(el => el.addEventListener('click', this.bound_clearPalette));
          [...this.shadowRoot.querySelectorAll('.load-palette-button')].forEach(el => el.addEventListener('click', this.bound_loadPalette));
          [...this.shadowRoot.querySelectorAll('.clear-map-button')].forEach(el => el.addEventListener('click', this.bound_clearMap));
          document.addEventListener('settings-stored', this.bound_render);
        }
      
        removeEvents() {
          this.shadowRoot.querySelector('#save-current-palette-button').removeEventListener('click', this.bound_saveCurrentPalettes);
          [...this.shadowRoot.querySelectorAll('.clear-palette-button')].forEach(el => el.removeEventListener('click', this.bound_clearPalette));
          [...this.shadowRoot.querySelectorAll('.load-palette-button')].forEach(el => el.removeEventListener('click', this.bound_loadPalette));
          [...this.shadowRoot.querySelectorAll('.clear-map-button')].forEach(el => el.removeEventListener('click', this.bound_clearMap));
          document.removeEventListener('settings-stored', this.bound_render);
        }
      
        get paletteTool() {
          return document.querySelector('palette-tool');
        }
      
        saveCurrentPalettes() {
          document.body.insertAdjacentHTML('beforeend', '<save-palettes-dialog></save-palettes-dialog>');
          document.querySelector('save-palettes-dialog').addEventListener('save', ({ detail: { label, palettes } }) => {
            this.settings.savePalettes({ label, palettes });
            this.render();
          });
        }
      
        clearPalette({ target }) {
          this.settings.removePalette(target.getAttribute('group-id'));
          this.render();
        }
      
        loadPalette({ target }) {
          this.settings.getPaletteGroup(target.getAttribute('group-id')).palettes.forEach((palette, i) => {
            this.paletteTool.setPalette(i, palette);
          });
        }
      
        clearMap({ target }) {
          this.settings.removeColorMap(target.getAttribute('group-id'));
          this.render();
        }
      
        styles() {
          return css`
            :host {
              display: block;
            }
      
            .divider {
              border-bottom: 1px solid #999;
            }
      
            .spacer {
              padding-top: 12px;
            }
      
            .top-row {
              display: flex;
              align-items: center;
            }
      
            .title {
              font-size: 18px;
              font-weight: 400;
              padding-left: 6px;
              flex: 1;
            }
      
            .subtitle {
              font-size: 14px;
              padding-left: 6px;
              flex: 1;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .settings {
              margin: 18px 0;
            }
      
            .settings .sub {
              margin-top: 6px;
              margin-left: 12px;
            }
      
            .setting-input {
              width: 40px;
              margin-right: 22px;
            }
      
            .palette-container {
              width: 312px;
              margin: 6px;
            }
      
            .palette {
              display: flex;
              flex-direction: row;
              padding: 6px;
            }
      
            .palette label {
              font-size: 14px;
              font-weight: bold;
              color: #666;
              padding-right: 12px;
            }
      
            .palette button {
              margin-left: 6px;
            }
      
            .color {
              flex: 1;
              height: 24px;
              border: 3px solid rgba(0,0,0,0);
              box-sizing: border-box;
            }
          `;
        }
      
        template() {
          return html`
            <div class="palette-container">
              <div class="top-row">
                <div class="title">Settings</div>
              </div>
      
              <div class="row">
                <button id="save-current-palette-button">Save current palettes</button>
              </div>
      
              <div class="settings">
                <div class="subtitle">Saved Palettes</div>
      
                <div class="sub">
                  ${this.settings.palettes.map(({id, label, palettes}) => html`
                    <div class="palette-group">
                      <div class="row" style="padding: 8px;">
                        <label style="flex: 1;">${label}</label>
                        <button class="clear-palette-button" style="margin-right: 8px;" group-id="${id}">clear</button>
                        <button class="load-palette-button" group-id="${id}">load</button>
                      </div>
                      ${palettes.map(palette => html`
                        <div class="palette">
                          ${palette.map(c => html`<div class="color" style="background-color: ${ColorUtils.ArrayToRBGA(c)};"></div>`).join('\n')}
                        </div>
                      `).join('\n')}
                    </div>
                  `).join('\n')}
                </div>
              </div>
      
      
              <div class="subtitle" style="margin-top: 48px;">Saved Color maps</div>
              <div>
                <div class="sub">
                  ${this.settings.colorMaps.map(({id, label, map}) => html`
                    <div class="palette-group">
                      <div class="row" style="padding: 8px;">
                        <label style="flex: 1;">${label}</label>
                        <button class="clear-map-button" style="margin-right: 8px;" group-id="${id}">clear</button>
                      </div>
                    </div>
                  `).join('\n')}
                </div>
              </div>
            </div>
          `;
        }
      });
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','save-palettes-dialog--template');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 11;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .container {
        display: inline-block;
        position: relative;
        left: 50%;
        top: 50%;
        width: 360px;
        height: auto;
        transform: translate(-50%, -50%);
      
        background-color: #DDD;
        border: 1px solid #999;
        border-radius: 3px;
        box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                    0 8px 10px 1px rgba(0,0,0,.14),
                    0 3px 14px 2px rgba(0,0,0,.12);
      }
      
      .title {
        font-size: 22px;
        color: #444;
        margin-bottom: 24px;
      }
      
      .sub-title {
        font-size: 20px;
        color: #444;
        margin-bottom: 18px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      .content {
        padding: 24px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .column {
        display: flex;
        flex-direction: column;
      }
      
      .controls {
        margin-top: 24px;
      }
      
      button {
        align-items: center;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
        display: inline-flex;
        font-size: 14px;
        font-weight: 500;
        height: 33px;
        justify-content: center;
        line-height: 32px;
        min-width: 64px;
        outline: none;
        overflow: hidden;
        padding: 0 8px 0 8px;
        position: relative;
        vertical-align: middle;
        margin: 0;
        background-color: white;
      }
      
      button:hover {
        cursor: pointer;
        background-color: #EEE;
      }
      
      .palette {
        display: flex;
        flex-direction: row;
      }
      
      .color {
        flex: 1;
        height: 24px;
        border: 3px solid rgba(0,0,0,0);
        box-sizing: border-box;
      }
      
      label {
        padding-right: 4px;
      }
      
      input {
        width: 80px;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="content">
          <div class="title">Save</div>
      
          <div class="row">
            <label for="label">Label:</label>
            <input name="label">
          </div>
      
          <br/>
      
          <div class="column">
            
          </div>
      
          <br/>
      
          <div class="controls">
            <button id="save-button">save</button>
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("save-palettes-dialog", class extends HTMLElementExtended {
        constructor() {
          super("save-palettes-dialog");
          this.cloneTemplate(true);
        }
      
        connectedCallback() {
          this.bound_save = this.save.bind(this);
          this.saveButton.addEventListener('click', this.bound_save);
        }
      
        disconnectedCallback() {
          this.saveButton.removeEventListener('click', this.bound_save);
        }
      
        get saveButton() {
          return this.shadowRoot.querySelector('#save-button');
        }
      
        get paletteTool() {
          return document.querySelector('palette-tool');
        }
      
        get palettes() {
          return this.paletteTool.palettes || [];
        }
      
        save() {
          this.dispatchEvent(new CustomEvent('save', {
            detail: {
              label: this.shadowRoot.querySelector('input[name="label"]').value,
              palettes: this.palettes
            }
          }));
          this.remove();
        }
      
        styles() {
          return css`
            :host {
              display: block;
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              z-index: 11;
              background-color: rgba(0, 0, 0, 0.5);
            }
      
            .container {
              display: inline-block;
              position: relative;
              left: 50%;
              top: 50%;
              width: 360px;
              height: auto;
              transform: translate(-50%, -50%);
      
              background-color: #DDD;
              border: 1px solid #999;
              border-radius: 3px;
              box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                          0 8px 10px 1px rgba(0,0,0,.14),
                          0 3px 14px 2px rgba(0,0,0,.12);
            }
      
            .title {
              font-size: 22px;
              color: #444;
              margin-bottom: 24px;
            }
      
            .sub-title {
              font-size: 20px;
              color: #444;
              margin-bottom: 18px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            .content {
              padding: 24px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .column {
              display: flex;
              flex-direction: column;
            }
      
            .controls {
              margin-top: 24px;
            }
      
            button {
              align-items: center;
              border: none;
              border-radius: 4px;
              box-sizing: border-box;
              display: inline-flex;
              font-size: 14px;
              font-weight: 500;
              height: 33px;
              justify-content: center;
              line-height: 32px;
              min-width: 64px;
              outline: none;
              overflow: hidden;
              padding: 0 8px 0 8px;
              position: relative;
              vertical-align: middle;
              margin: 0;
              background-color: white;
            }
      
            button:hover {
              cursor: pointer;
              background-color: #EEE;
            }
      
            .palette {
              display: flex;
              flex-direction: row;
            }
      
            .color {
              flex: 1;
              height: 24px;
              border: 3px solid rgba(0,0,0,0);
              box-sizing: border-box;
            }
      
            label {
              padding-right: 4px;
            }
      
            input {
              width: 80px;
            }
          `;
        }
      
      
        template() {
          return html`
            <div class="container">
              <div class="content">
                <div class="title">Save</div>
      
                <div class="row">
                  <label for="label">Label:</label>
                  <input name="label">
                </div>
      
                <br/>
      
                <div class="column">
                  ${this.palettes.map((p, i) => html`
                    <div class="palette">
                      ${p.map((c, j) => html`<div class="color" style="background-color: ${ColorUtils.ArrayToRBGA(p[j])};" id="settings-color:${i}-${j}"></div>`).join('\n')}
                    </div>
                  `)}
                </div>
      
                <br/>
      
                <div class="controls">
                  <button id="save-button">save</button>
                </div>
              </div>
            </div>
          `;
        }
      });
          });
        
    
      // Pages
      class Home extends Page {
        constructor() {
          super();
      
          this.canvasWidth = 160;
          this.canvasHeight = 144;
          this.scale = 4;
          this.disableEntry = false;
          this.canvasPlaneX = 0;
          this.canvasPlaneY = 0;
          this.bound_extractButtonClick = this.extractButtonClick.bind(this);
        }
      
        connectedCallback() {
          this.bound_paletteChange = this.paletteChange.bind(this);
          this.paletteTool.addEventListener('change', this.bound_paletteChange);
          this.centerCanvas();
          this.canvas.color = this.paletteTool.rawColor;
          this.canvas.altColor = this.paletteTool.rawAltColor;
          this.canvas.tileWidth = 8;
          this.canvas.tileHeight = 8;
          this.bound_onCreate = this.onCreate.bind(this);
          this.bound_onColorPick = this.onColorPick.bind(this);
          if (!this.disableEntry) this.entryDialog.addEventListener('create', this.bound_onCreate);
      
          this.canvas.addEventListener('colorPicked', this.bound_onColorPick);
      
          this.tilePaletteValidator.canvas = this.canvas;
          this.tilePaletteValidator.paletteTool = this.paletteTool;
      
          this.bound_onKeyPress = this.onKeyPress.bind(this);
          this.bound_onKeyRelease = this.onKeyRelease.bind(this);
          this.bound_onMouseMove = this.onMouseMove.bind(this);
          document.addEventListener('keydown', this.bound_onKeyPress);
          document.addEventListener('keyup', this.bound_onKeyRelease);
          document.addEventListener('mousemove', this.bound_onMouseMove);
          document.querySelector('#mapper-button').addEventListener('click', this.bound_extractButtonClick);
        }
      
        disconnectedCallback() {
          this.paletteTool.removeEventListener('change', this.bound_paletteChange);
          if (!this.disableEntry) this.entryDialog.removeEventListener('create', this.bound_onCreate);
          this.canvas.removeEventListener('colorPicked', this.bound_onColorPick);
          document.removeEventListener('keydown', this.bound_onKeyPress);
          document.removeEventListener('keyup', this.bound_onKeyRelease);
          document.removeEventListener('mousemove', this.bound_onMouseMove);
          document.querySelector('#mapper-button').removeEventListener('click', this.bound_extractButtonClick);
        }
      
        get title() {
          return 'Home';
        }
      
        get paletteTool() {
          return document.querySelector('palette-tool');
        }
      
        get canvas() {
          return document.querySelector('draw-canvas');
        }
      
        get entryDialog() {
          return document.querySelector('entry-dialog');
        }
      
        get tilePaletteValidator() {
          return document.querySelector('tile-palette-validator');
        }
      
        paletteChange(e) {
          this.canvas.color = e.detail.selectedColor;
          this.canvas.altColor = e.detail.altColor;
        }
      
        onCreate(e) {
          this.entryDialog.removeEventListener('create', this.bound_onCreate);
      
          // set tile size and update the grid overlay settings
          const gridSettings = document.querySelector('grid-settings');
          gridSettings.valueX = e.detail.tile.x;
          gridSettings.valueY = e.detail.tile.y;
          this.canvas.tileWidth = e.detail.tile.x;
          this.canvas.tileHeight = e.detail.tile.y;
      
          // set canvas size
          // TODO implament cancas size
          this.canvasWidth = e.detail.size.x;
          this.canvasHeight = e.detail.size.y;
          this.canvas.width = this.canvasWidth;
          this.canvas.height = this.canvasHeight;
          this.centerCanvas();
      
          // set palette
          this.paletteTool.colorCount = e.detail.palette.colorCount;
          this.paletteTool.count = e.detail.palette.count;
      
          // this.paletteTool.setPalette(0, [
          //   [198, 209, 211, 1],
          //   [81, 125, 136, 1],
          //   [139, 133, 109, 1],
          //   [0, 0, 0, 1]
          // ]);
          //
          // this.paletteTool.setPalette(1, [
          //   [139, 133, 109, 1],
          //   [34, 34, 34, 1],
          //   [11, 13, 13, 1],
          //   [0, 0, 0, 1]
          // ]);
      
          // this.paletteTool.setPalette(0, [
          //   [208, 32, 127, 1],
          //   [153, 23, 93, 1],
          //   [97, 15, 59, 1],
          //   [0, 0, 0, 1]
          // ]);
        }
      
        centerCanvas() {
          const canvasPlane = document.querySelector('.canvas-plane');
          const containerBounds = document.querySelector('.canvas-container').getBoundingClientRect();
          const canvasBounds = this.canvas.getBoundingClientRect();
          this.canvasPlaneX = (containerBounds.width / 2) - (canvasBounds.width / 2);
          this.canvasPlaneY = (containerBounds.height / 2) - (canvasBounds.height / 2);
          canvasPlane.style.left = `${this.canvasPlaneX}px`;
          canvasPlane.style.top = `${this.canvasPlaneY}px`;
        }
      
        scaleCanvas(scale) {
          this.canvas.scale = scale;
          this.centerCanvas();
        }
      
        updateGrid(show, x, y) {
          if (show) {
            this.canvas.gridSize = {x, y};
            this.canvas.showGrid();
          } else this.canvas.hideGrid();
        }
      
        showSaveDialog() {
          document.querySelector('.main-container').insertAdjacentHTML('beforebegin', '<save-dialog></save-dialog>');
          const el = document.querySelector('save-dialog');
          el.canvas = this.canvas;
          el.paletteTool = this.paletteTool;
        }
      
        showUploadDialog() {
          document.querySelector('.main-container').insertAdjacentHTML('beforebegin', '<upload-dialog></upload-dialog>');
          const el = document.querySelector('upload-dialog');
          el.canvas = this.canvas;
        }
      
        pencilTool() {
          this.canvas.pencil();
        }
      
        colorPickerTool() {
          this.canvas.colorPicker();
        }
      
        brushTool() {
          this.canvas.brush();
        }
      
        onColorPick(e) {
          this.paletteTool.color = e.detail.color;
        }
      
        onKeyPress(e) {
          switch (e.keyCode) {
            case 32:
              this.spacePressed = true;
              break;
          }
        }
      
        onKeyRelease(e) {
          switch (e.keyCode) {
            case 32:
              this.spacePressed = false;
              break;
          }
        }
      
        onMouseMove(e) {
          if (this.spacePressed) {
            const canvasPlane = document.querySelector('.canvas-plane');
            this.canvasPlaneX += e.movementX;
            this.canvasPlaneY += e.movementY;
            canvasPlane.style.left = `${this.canvasPlaneX}px`;
            canvasPlane.style.top = `${this.canvasPlaneY}px`;
          }
        }
      
        extractButtonClick(e) {
          document.body.insertAdjacentHTML('beforeend', '<palette-mapper></palette-mapper>');
          const el = document.querySelector('palette-mapper');
          el.addEventListener('change', (e) => {
            e.detail.colorMap.forEach((p, i) => {
              this.paletteTool.setPalette(i, Object.keys(p).map(ColorUtils.RGBToArray));
            })
            this.canvas.remapColors(e.detail.colorMap);
          });
        }
      
        template() {
          return html`
            ${!this.disableEntry ? '<entry-dialog></entry-dialog>' : ''}
      
            <div class="main-container">
              <div class="tool-bar">
                <div class="icon-button" onclick="$Home.pencilTool();">edit</div>
                <div class="icon-button" onclick="$Home.brushTool();">brush</div>
                <div class="icon-button-svg" onclick="$Home.colorPickerTool();">
                  <img src="eyedropper.svg" alt="color-picker">
                </div>
                <div class="icon-button-svg">
                  <img src="format-color-fill.svg" alt="color-fill">
                </div>
                <div style="flex: 1;"></div>
                <div class="icon-button-svg" onclick="$Home.showUploadDialog()">
                  <img src="file-upload.svg" alt="image-upload">
                </div>
                <div class="icon-button" onclick="$Home.showSaveDialog()">save</div>
              </div>
              <div class="canvas-container">
                <div class="canvas-plane">
                  <!-- TODO replace with component -->
                  <draw-canvas width="${this.canvasWidth}" height="${this.canvasHeight}" scale="4"></draw-canvas>
                </div>
                <div class="scale-container">
                  <tile-palette-validator></tile-palette-validator>
                  <scale-range min="1" max="10" value="4" onchange="$Home.scaleCanvas(this.value)"></scale-range>
                  <grid-settings onchange="$Home.updateGrid(this.show, this.valueX, this.valueY)"></grid-settings>
                </div>
              </div>
              <div class="settings-container">
                <palette-tool count="4" color-count="4"></palette-tool>
      
                <div class="divider"></div>
      
                <div style="padding: 10px;">
                  <button id="mapper-button">Convert cavas colors to Palette</button>
                </div>
      
                <div class="divider"></div>
      
                <settings-tool></settings-tool>
              </div>
            </div>
          `;
        }
      }
    
      // build initial page
      window.$Home = new Home();
      window.currentPageClass = window.$Home;
      setTimeout(function () {
        $Home.connectedCallback();
      }, 0);
    </script>
    
    <!-- --- Styles --- -->
    <style>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </style>
  </head>

  <body>
    <render-block-page>
      <entry-dialog></entry-dialog>
      
      <div class="main-container">
        <div class="tool-bar">
          <div class="icon-button" onclick="$Home.pencilTool();">edit</div>
          <div class="icon-button" onclick="$Home.brushTool();">brush</div>
          <div class="icon-button-svg" onclick="$Home.colorPickerTool();">
            <img src="eyedropper.svg" alt="color-picker">
          </div>
          <div class="icon-button-svg">
            <img src="format-color-fill.svg" alt="color-fill">
          </div>
          <div style="flex: 1;"></div>
          <div class="icon-button-svg" onclick="$Home.showUploadDialog()">
            <img src="file-upload.svg" alt="image-upload">
          </div>
          <div class="icon-button" onclick="$Home.showSaveDialog()">save</div>
        </div>
        <div class="canvas-container">
          <div class="canvas-plane">
            <!-- TODO replace with component -->
            <draw-canvas width="160" height="144" scale="4"></draw-canvas>
          </div>
          <div class="scale-container">
            <tile-palette-validator></tile-palette-validator>
            <scale-range min="1" max="10" value="4" onchange="$Home.scaleCanvas(this.value)"></scale-range>
            <grid-settings onchange="$Home.updateGrid(this.show, this.valueX, this.valueY)"></grid-settings>
          </div>
        </div>
        <div class="settings-container">
          <palette-tool count="4" color-count="4"></palette-tool>
      
          <div class="divider"></div>
      
          <div style="padding: 10px;">
            <button id="mapper-button">Convert cavas colors to Palette</button>
          </div>
      
          <div class="divider"></div>
      
          <settings-tool></settings-tool>
        </div>
      </div>
    </render-block-page>
  </body>
</html>