<!doctype html>
<html lang="en">
  <head>
    <title>Home</title>

    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

    <link rel="stylesheet" href="main.css">
    <script>
      
        window.html = function (strings, ...expressionValues) {
          let finalString = '';
          let i = 0;
          let length = strings.length;
          for(; i < length; i++) {
            if (i > 0) finalString += expressionValues[i - 1];
            finalString += strings[i];
          }
          return finalString;
        };
        window.stripIndents = function (strings, ...expressionValues) {
          let finalString = '';
          let i = 0;
          let length = strings.length;
          for(; i < length; i++) {
            if (i > 0) finalString += expressionValues[i - 1];
            finalString += strings[i];
          }
          const match = finalString.match(/^[^\S\n]*(?=\S)/gm);
          const indent = match && Math.min(...match.map(el => el.length));
          if (indent) {
            const regexp2 = new RegExp('^.{'+indent+'}', 'gm');
            return finalString.replace(regexp2, '');
          }
          return finalString;
        };
        window.escapeHTML = function (html) {
          return html.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        };
        window.htmlSafe = window.html;
        window.css = window.html;
        window.stripIndent = window.html;
        window.oneLine = window.html;
        window.oneLineTrim = window.html;
      
      
      const router = new class Router {
        constructor(routes) {
          this.routes = routes;
          if (this.routes['/404']) this._notFountRoute = this.routes['/404'];
      
          this.PARAMETER_REGEXP = /([:*])(\w+)/g;
          this.WILDCARD_REGEXP = /\*/g;
          this.REPLACE_VARIABLE_REGEXP = '([^\/]+)';
          this.REPLACE_WILDCARD = '(?:.*)';
          this.FOLLOWED_BY_SLASH_REGEXP = '(?:\/$|$)';
          this.MATCH_REGEXP_FLAGS = '';
      
          window.addEventListener('hashchange', this.resolve.bind(this));
          window.addEventListener('DOMContentLoaded', () => {
            this.resolve();
          });
        }
      
        resolve() {
          const path = this.path();
          const match = this.match(path);
      
          if (match === false) {
            if (this._notFountRoute) return this.changePage(this._notFountRoute);
            else return console.warn('no page found and no default not found page setup');
          }
      
          let url = path;
          let GETParameters = this.extractGETParameters(this.getCurrent());
          if (GETParameters) url += `?${GETParameters}`;
          window.location.hash = url;
          return this.changePage(match.className);
        }
      
        changePage(className) {
          // disconnect current page before rendering next one
          if (window.currentPageClass.disconnectedCallback) window.currentPageClass.disconnectedCallback();
      
          const id = '$'+className;
          window[id] = eval('new ' + className + '()');
          window.currentPageClass = window[id];
          window[id].render();
          const pageTitle = document.querySelector('title');
          if (pageTitle) pageTitle.innerText = window[id].title;
          setTimeout(() => {
            if (window[id].connectedCallback) window[id].connectedCallback();
          }, 0);
        }
      
        path() {
          let path = window.location.hash.replace(/.*#/, '');
          if (path.includes('?')) path = path.split('?')[0];
          if (path.charAt(0) !== '/') { path = '/'+path; }
          return path;
        }
      
        getCurrent() {
          return this.clean(window.location.href);
        }
      
        clean(str) {
          if (str instanceof RegExp) return s;
          return str.replace(/\/+$/, '').replace(/^\/+/, '/');
        }
      
        extractGETParameters(url) {
          return url.split(/\?(.*)?$/).slice(1).join('');
        }
      
        getParameters() {
          return this.extractGETParameters(this.getCurrent()).split(',').filter(a => !!a).reduce((a, b) => {
            const split = b.split('=');
            a[split[0]] = split[1];
            return a;
          }, {});
        }
      
        getParameter(name) {
          return this.getParameters()[name];
        }
      
        addParameter(name, value) {
          const url = this.getCurrent();
          const parameters = this.getParameters();
          parameters[name] = value;
          window.location.href = window.location.href.split('?')[0] + '?' + Object.keys(parameters).map(key => `${key}=${parameters[key]}`).join(',');
        }
      
        match(url) {
          let matched = this.findMatchedRoutes(url);
          if (!matched.length) return false;
          else if (matched.length === 1) return matched[0];
          else {
            return matched.sort((a, b) => {
              if (b.params) return 1;
              return -1;
            })[0];
          }
        }
      
        findMatchedRoutes(url) {
          return Object.keys(this.routes)
            .map(route => {
              var { regexp, paramNames } = this.replaceDynamicURLParts(this.clean(route));
              var match = url.replace(/^\/+/, '/').match(regexp);
              var params = this.regExpResultToParams(match, paramNames);
              return !match ? false : {
                match,
                route,
                params,
                className: this.routes[route]
              };
            })
            .filter(m => m && m.match[0] !== '');
        }
      
        replaceDynamicURLParts(route) {
          let paramNames = [];
          let regexp = '';
      
          if (route instanceof RegExp) {
            regexp = route;
          } else {
            regexp = new RegExp(
              this.clean(route)
                .replace(this.PARAMETER_REGEXP, (full, dots, name) => {
                  paramNames.push(name);
                  return this.REPLACE_VARIABLE_REGEXP;
                })
                .replace(this.WILDCARD_REGEXP, this.REPLACE_WILDCARD) + this.FOLLOWED_BY_SLASH_REGEXP, this.MATCH_REGEXP_FLAGS
            );
          }
          return { regexp, paramNames };
        }
      
        regExpResultToParams(match, names) {
          if (names.length === 0) return null;
          if (!match) return null;
          return match
            .slice(1, match.length)
            .reduce((params, value, index) => {
              if (params === null) params = {};
              params[names[index]] = decodeURIComponent(value);
              return params;
            }, null);
        }
      }({
        "/home": "Home",
        "/404": "noop",
        "/": "Home"
      });
      
      class Page {
        constructor() {}
        connectedCallback() {}
        template() { return ''; }
        styles() { return ''; }
        beforeRender() {}
        render() {
          if (this.beforeRender) this.beforeRender();
          const renderBlock = document.querySelector('render-block-page');
          if (!renderBlock) throw Error('Could not find <render-block-page>');
          renderBlock.innerHTML = `<style>${this.styles()}</style>${this.template()}`;
          if (this.afterRender) this.afterRender();
        }
        afterRender() {}
      }
    
      
      window.TilePaletteChecker = class TilePaletteChecker {
        constructor(canvas, palette) {
          this.canvas = canvas;
          this.paletteTool = palette;
        }
      
        get tileSize() {
          return this.canvas.gridSize;
        }
      
        get canvasSize() {
          return {
            width: this.canvas.width,
            height: this.canvas.height
          }
        }
      
        get palettes() {
          return this.paletteTool.palettes.map(p => this.convertRGBAArrToInt(p));
        }
      
        check() {
          const { tileColors, rawTileData } = this.canvas.getTileData();
          const palettes = this.palettes;
          const paletteColorLength = palettes[0].length;
          const invalidTiles = [];
      
          const tileValidationData = tileColors.map((t, i) => {
            const tileColors = Object.keys(t).map(parseInt);
            const colorCount = tileColors.length;
            const paletteMatch = this.matchPalette(palettes, tileColors);
            let valid = true;
            let reason;
      
            if (colorCount > paletteColorLength) {
              valid = false;
              reason = `More than ${paletteColorLength} colors. Found ${colorCount} in tile`;
            }
            if (paletteMatch === undefined) {
              valid = false;
              reason = 'no palette match';
            }
            if (!valid) invalidTiles.push(i);
      
            return {
              valid,
              tileId: i,
              reason,
              palette: paletteMatch,
              colors: tileColors
            };
          });
      
          return {
            rawTileData,
            tileValidationData,
            invalidTiles,
            valid: invalidTiles.length > 0
          };
        }
      
        matchPalette(palettes, tileColors) {
          let tileColorLength = tileColors.length;
          let palleteLength = palettes.length;
          let i = 0;
          let j;
          let match = true;
      
          for (; i < palleteLength; i += 1) {
            for (j = 0; j < tileColorLength; j += 1) {
              if (!palettes[i].includes(tileColors[j])) match = false;
            }
      
            if (match === true) return i;
          }
      
          return undefined;
        }
      
        convertRGBAArrToInt(arr) {
          return arr.map(this.RGBAtoInt);
        }
      
        RGBAtoInt(arr) {
          return ((Math.round(arr[3] * 255) << 24) >>> 0 | arr[0] << 16 | arr[1] << 8 | arr[2]) >>> 0;
        }
      
        intToRGBA(num) {
          return `rgba(${num >> 24 & 255},${num >> 16 & 255},${num >> 8  & 255},${(num & 255) / 255})`;
        }
      }
      window.Utils = class Utils {
        static debounce(fn, wait) {
          let timer;
          return function debounced() {
            const args = arguments;
            const context = this
            clearTimeout(timer);
            timer = setTimeout(() => {
              timer = undefined;
              fn.apply(context, args);
            }, wait || 10);
          };
        }
      
        static throttle(fn, limit) {
          let alreadyQueued;
          return function throttled() {
            const args = arguments;
            const context = this;
            if (!alreadyQueued) {
              alreadyQueued = true;
              fn.apply(context, args);
              setTimeout(() => {
                alreadyQueued = false;
              }, limit);
            }
          };
        }
      
        // throttle on request animation frameyy
        static rafThrottle(fn) {
          let alreadyQueued;
          return function throttled() {
            const args = arguments;
            const context = this;
            if (!alreadyQueued) {
              alreadyQueued = true;
              fn.apply(context, args);
              requestAnimationFrame(() => {
                alreadyQueued = false;
              });
            }
          };
        }
      }
    
      
          document.addEventListener("DOMContentLoaded", function (event) {
            (function(){
          var t=document.createElement('template');
          t.setAttribute('id','color-picker');
          t.innerHTML=`
          <style>
            :host {
        display: block;
      }
      
      .picking-container {
        vertical-align: top;
        position: relative;
        height: 150px;
        width: 300px;
        padding: 5px;
        user-select: none;
      }
      
      .picker {
        height: 10px;
        width: 10px;
        border: 1px white solid;
        border-radius: 11px;
        position: absolute;
        cursor: pointer;
        z-index: 10;
        user-select: none;
      }
      
      .striper {
        height: 2px;
        left: 192px;
        width: 30px;
        border: 1px white solid;
        position: absolute;
        cursor: pointer;
        z-index: 10;
        user-select: none;
      }
      
      .picking-container.no-mouse { cursor: none; }
      .picking-container.no-mouse .picker { cursor: none; }
      .picking-container.no-mouse .striper { cursor: none; }
      
      .rgba-values {
        display: inline-block;
        vertical-align: top;
        width: 65px;
        padding-left: 8px;
      }
      
      .input-container {
        flex: 1;
        display: flex;
        flex-direction: row;
        padding-bottom: 6px;
      }
      
      .input-container label {
        font-size: 14px;
        width: 24px;
      }
      
      .input-container input {
        width: 40px;
      }
          </style>
          <render-block>
            <div class="picking-container">
        <div class="picker" style="left: 180px; top: 0px;"></div>
        <div class="striper" style="top: 10px;"></div>
        <canvas id="current-color" height="150" width="30"></canvas>
        <canvas id="color-block" height="150" width="150"></canvas>
        <canvas id="color-strip" height="150" width="30"></canvas>
        <div class="rgba-values">
          <div class="input-container">
            <label for="r-value">R</label>
            <input name="r-value">
          </div>
      
          <div class="input-container">
            <label for="g-value">G</label>
            <input name="g-value">
          </div>
      
          <div class="input-container">
            <label for="b-value">B</label>
            <input name="b-value">
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("color-picker", 
            class colorPicker extends HTMLElement {
              
          
        
          constructor() {
          super();
      
          this.pickerX = 150;
          this.pickerY = 0;
          this.colorBlockSize = 150;
          this.colorStripWidth = 30;
          this.rgbaColor = 'rgba(255,0,0,1)';
          this.pickerColor = this.rgbaColor;
      
          this.cloneTemplate();
        }
          
      
        connectedCallback() {
          this.colorBlockContext.rect(0, 0, this.colorBlockSizeh1, this.colorBlockSize);
          this.fillGradient();
      
          const ctx2 = this.colorStripContext;
          ctx2.rect(0, 0, this.colorStripWidth, this.colorBlockSize);
          const grd1 = ctx2.createLinearGradient(0, 0, 0, this.colorBlockSize);
          grd1.addColorStop(0, 'rgba(255, 0, 0, 1)');
          grd1.addColorStop(0.17, 'rgba(255, 255, 0, 1)');
          grd1.addColorStop(0.34, 'rgba(0, 255, 0, 1)');
          grd1.addColorStop(0.51, 'rgba(0, 255, 255, 1)');
          grd1.addColorStop(0.68, 'rgba(0, 0, 255, 1)');
          grd1.addColorStop(0.85, 'rgba(255, 0, 255, 1)');
          grd1.addColorStop(1, 'rgba(255, 0, 0, 1)');
          ctx2.fillStyle = grd1;
          ctx2.fill();
      
          this.setBlockColor();
          this.setPickerColor();
      
          // color block
          this.bound_colorBlockMouseDown = this.colorBlockMouseDown.bind(this);
          this.bound_colorBlockMouseUp = this.colorBlockMouseUp.bind(this);
          this.bound_colorBlockMouseMove = this.colorBlockMouseMove.bind(this);
          this.colorBlock.addEventListener('mousedown', this.bound_colorBlockMouseDown);
      
          // color strip
          this.bound_colorStripMouseDown = this.colorStripMouseDown.bind(this);
          this.bound_colorStripMouseUp = this.colorStripMouseUp.bind(this);
          this.bound_colorStripMouseMove = this.colorStripMouseMove.bind(this);
          this.colorStrip.addEventListener('mousedown', this.bound_colorStripMouseDown);
        }
      
        disconnectedCallback() {
          // color block
          this.colorBlock.removeEventListener('mousedown', this.bound_colorBlockMouseDown);
          document.removeEventListener('mouseup', this.bound_colorBlockMouseUp);
          document.removeEventListener('mousemove', this.bound_colorBlockMouseMove);
      
          // color strip
          this.colorStrip.removeEventListener('mousedown', this.bound_colorStripMouseDown);
          document.removeEventListener('mouseup', this.bound_colorStripMouseUp);
          document.removeEventListener('mousemove', this.bound_colorStripMouseMove);
        }
      
        static get observedAttributes() {
          return ['max-rgb-range'];
        }
      
        attributeChangedCallback(name, oldValue, newValue) {
          if (name === 'max-rgb-range') this.maxRGBRange = newValue;
        }
      
        get color() {
          const multiplier = this.maxRGBRange / 255;
          const values = this.pickerColor.replace('rgba(', '').replace(')', '').split(',');
          return [...values.slice(0, 3).map(v => v * multiplier), 1];
        }
      
        get maxRGBRange() {
          return this.maxRGBRange_ || 255;
        }
      
        set maxRGBRange(value) {
          if (value < 3) value = 3;
          if (value > 255) value = 255;
          this.maxRGBRange_ = value;
        }
      
        get colorBlock() {
          if (!this.colorBlock_) this.colorBlock_ = this.shadowRoot.querySelector('#color-block');
          return this.colorBlock_;
        }
      
        get colorBlockContext() {
          return this.colorBlock.getContext('2d');
        }
      
        get colorStrip() {
          return this.shadowRoot.querySelector('#color-strip');
        }
      
        get colorStripContext() {
          return this.colorStrip.getContext('2d');
        }
      
        get currentColor() {
          return this.shadowRoot.querySelector('#current-color');
        }
      
        get currentColorContext() {
          return this.currentColor.getContext('2d');
        }
      
        get picker() {
          if (!this.picker_) this.picker_ = this.shadowRoot.querySelector('.picker');
          return this.picker_;
        }
      
        get striper() {
          if (!this.striper_) this.striper_ = this.shadowRoot.querySelector('.striper');
          return this.striper_;
        }
      
        get pickingContainer() {
          return this.shadowRoot.querySelector('.picking-container');
        }
      
        get rInput() {
          return this.shadowRoot.querySelector('input[name="r-value"]');
        }
      
        get gInput() {
          return this.shadowRoot.querySelector('input[name="g-value"]');
        }
      
        get bInput() {
          return this.shadowRoot.querySelector('input[name="b-value"]');
        }
      
        setBlockColor() {
          const ctx3 = this.currentColorContext;
          ctx3.fillStyle = this.pickerColor;
          ctx3.fillRect(0, 0, this.colorStripWidth, this.colorBlockSize);
        }
      
        setPickerColor() {
          const x = this.pickerX - this.colorStripWidth;
          const y = this.pickerY;
          this.pickerColor = `rgba(${[...this.colorBlockContext.getImageData(x, y, 1, 1).data].slice(0, 3).join(',')},1)`;
          if (x === 0 && y === 0) this.pickerColor = 'rgba(255,255,255,0)';
          this.picker.style.backgroundColor = this.pickerColor;
          this.setRGBInputs();
          this.handleChange();
        }
      
        updatePicker(x, y) {
          const rect = this.colorBlock.getBoundingClientRect();
          x -= rect.left;
          x += this.colorStripWidth;
          y -= rect.top;
          if (x > this.colorBlockSize + this.colorStripWidth - 1) x = this.colorBlockSize + this.colorStripWidth - 1;
          if (x < this.colorStripWidth) x = this.colorStripWidth;
          if (y < 0) y = 0;
          if (y > this.colorBlockSize) y = this.colorBlockSize;
      
          // get image data for color
          this.pickerX = x;
          this.pickerY = y;
      
          // offset picker
          if (x < this.colorStripWidth + 5) x = this.colorStripWidth + 5;
          // set picker position
          this.picker.style.left = `${x}px`;
          this.picker.style.top = `${y}px`;
          this.setPickerColor();
        }
      
        updateStriper(y) {
          const rect = this.colorStrip.getBoundingClientRect();
          y -= rect.top;
          if (y < 0) y = 0;
          if (y > this.colorBlockSize) y = this.colorBlockSize;
      
          this.rgbaColor = `rgba(${[...this.colorStripContext.getImageData(1, y, 1, 1).data].slice(0, 3).join(',')},1)`;
          this.striper.style.top = `${y}px`;
          this.fillGradient();
          this.setPickerColor();
        }
      
        fillGradient() {
          const ctx1 = this.colorBlockContext;
          const ctx2 = this.colorStripContext;
      
          ctx1.fillStyle = this.rgbaColor;
          ctx1.fillRect(0, 0, this.colorBlockSize, this.colorBlockSize);
      
          const grdWhite = ctx2.createLinearGradient(0, 0, this.colorBlockSize, 0);
          grdWhite.addColorStop(0, 'rgba(255,255,255,1)');
          grdWhite.addColorStop(1, 'rgba(255,255,255,0)');
          ctx1.fillStyle = grdWhite;
          ctx1.fillRect(0, 0, this.colorBlockSize, this.colorBlockSize);
      
          const grdBlack = ctx2.createLinearGradient(0, 0, 0, this.colorBlockSize);
          grdBlack.addColorStop(0, 'rgba(0,0,0,0)');
          grdBlack.addColorStop(1, 'rgba(0,0,0,1)');
          ctx1.fillStyle = grdBlack;
          ctx1.fillRect(0, 0, this.colorBlockSize, this.colorBlockSize);
        }
      
        setRGBInputs() {
          const values = this.pickerColor.replace('rgba(', '').replace(')', '').split(',');
          this.rInput.value = values[0];
          this.gInput.value = values[1];
          this.bInput.value = values[2];
        }
      
      
        // --- color block mouse events ---
      
        colorBlockMouseDown(e) {
          this.isColorBlockMouseDown = true;
          this.pickingContainer.classList.add('no-mouse');
          this.updatePicker(e.clientX, e.clientY);
          document.addEventListener('mouseup', this.bound_colorBlockMouseUp);
          document.addEventListener('mousemove', this.bound_colorBlockMouseMove);
        }
      
        colorBlockMouseUp() {
          this.isColorBlockMouseDown = false;
          this.pickingContainer.classList.remove('no-mouse');
          this.setBlockColor();
        }
      
        colorBlockMouseMove(e) {
          if (this.isColorBlockMouseDown) {
            this.updatePicker(e.clientX, e.clientY);
          }
        }
      
      
        // --- color strip mouse events ---
      
        colorStripMouseDown(e) {
          this.isColorStripMouseDown = true;
          this.pickingContainer.classList.add('no-mouse');
          this.updateStriper(e.clientY);
          document.addEventListener('mouseup', this.bound_colorStripMouseUp);
          document.addEventListener('mousemove', this.bound_colorStripMouseMove);
        }
      
        colorStripMouseUp() {
          this.isColorStripMouseDown = false;
          this.pickingContainer.classList.remove('no-mouse');
          // this.setBlockColor();
        }
      
        colorStripMouseMove(e) {
          if (this.isColorStripMouseDown) {
            this.updateStriper(e.clientY);
          }
        }
      
        handleChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              color: this.color
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
            }
      
            .picking-container {
              vertical-align: top;
              position: relative;
              height: 150px;
              width: 300px;
              padding: 5px;
              user-select: none;
            }
      
            .picker {
              height: 10px;
              width: 10px;
              border: 1px white solid;
              border-radius: 11px;
              position: absolute;
              cursor: pointer;
              z-index: 10;
              user-select: none;
            }
      
            .striper {
              height: 2px;
              left: 192px;
              width: ${this.colorStripWidth}px;
              border: 1px white solid;
              position: absolute;
              cursor: pointer;
              z-index: 10;
              user-select: none;
            }
      
            .picking-container.no-mouse { cursor: none; }
            .picking-container.no-mouse .picker { cursor: none; }
            .picking-container.no-mouse .striper { cursor: none; }
      
            .rgba-values {
              display: inline-block;
              vertical-align: top;
              width: 65px;
              padding-left: 8px;
            }
      
            .input-container {
              flex: 1;
              display: flex;
              flex-direction: row;
              padding-bottom: 6px;
            }
      
            .input-container label {
              font-size: 14px;
              width: 24px;
            }
      
            .input-container input {
              width: 40px;
            }
          `;
        }
      
        template() {
          return html`
            <div class="picking-container">
              <div class="picker" style="left: ${this.colorBlockSize + this.colorStripWidth}px; top: 0px;"></div>
              <div class="striper" style="top: 10px;"></div>
              <canvas id="current-color" height="${this.colorBlockSize}" width="${this.colorStripWidth}"></canvas>
              <canvas id="color-block" height="${this.colorBlockSize}" width="${this.colorBlockSize}"></canvas>
              <canvas id="color-strip" height="${this.colorBlockSize}" width="${this.colorStripWidth}"></canvas>
              <div class="rgba-values">
                <div class="input-container">
                  <label for="r-value">R</label>
                  <input name="r-value">
                </div>
      
                <div class="input-container">
                  <label for="g-value">G</label>
                  <input name="g-value">
                </div>
      
                <div class="input-container">
                  <label for="b-value">B</label>
                  <input name="b-value">
                </div>
              </div>
            </div>
          `;
        }
      
      
          
          
        
      
              render() {
                if (this.beforeRender) this.beforeRender();
                const renderBlock = this.shadowRoot.querySelector('render-block');
                if (!renderBlock) throw Error('Could not find <render-block>');
                renderBlock.innerHTML = this.template();
                if (this.afterRender) this.afterRender();
              }
      
              cloneTemplate(rerender = false) {
                var template = document.getElementById('color-picker');
                var templateContent = template.content;
                var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
                var clone = templateContent.cloneNode(true);
                if (rerender) clone.querySelector('render-block').innerHTML = this.template();
                shadowRoot.appendChild(clone);
              }
            }
          );
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','palette-tool');
          t.innerHTML=`
          <style>
            :host {
        display: block;
      }
      
      .palette-container {
        width: 312px;
        margin: 6px;
      }
      
      .palette {
        display: flex;
        flex-direction: row;
        padding: 6px;
      }
      
      .color {
        flex: 1;
        height: 24px;
        border: 3px solid rgba(0,0,0,0);
        box-sizing: border-box;
      }
      
      .color:hover {
        border: 3px solid #AAA;
      }
      
      .color.selected {
        border: 3px solid rgb(0, 159, 218, 0.7);
      }
      
      .divider {
        border-bottom: 1px solid #999;
      }
      
      .spacer {
        padding-top: 12px;
      }
      
      .top-row {
        display: flex;
        align-items: center;
      }
      
      .title {
        margin-left: 32px;
        font-size: 18px;
        font-weight: 400;
        padding-left: 6px;
        flex: 1;
      }
      
      .edit-label {
        color: #666;
        font-size: 14px;
        font-weight: bold;
        padding-right: 6px;
      }
      
      .palette-select {
        margin-left: 8px;
        margin-right: 12px;
      }
          </style>
          <render-block>
            <div class="palette-container">
        <div class="top-row">
          <div class="title">Palettes</div>
          <input type="checkbox" name="edit">
          <label class="edit-label" for="edit">Edit</label>
        </div>
        
                  
                  <div class="palette">
                    <input type="checkbox" checked id="palette-0" class="palette-select">
                    
                      <div class="color" style="background-color: rgba(0,0,0,1);" location="0-0"></div>
                    
        
                      <div class="color" style="background-color: rgba(63,63,63,1);" location="0-1"></div>
                    
        
                      <div class="color" style="background-color: rgba(127,127,127,1);" location="0-2"></div>
                    
        
                      <div class="color" style="background-color: rgba(191,191,191,1);" location="0-3"></div>
                    
                  </div>
        
                
      
        <div class="spacer"></div>
        <color-picker></color-picker>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("palette-tool", 
            class paletteTool extends HTMLElement {
              
          
        
          constructor() {
          super();
          this.cloneTemplate();
          this.selectedPalette = 0;
        }
          
      
        connectedCallback() {
          this.debounced_dispatchPaletteChange = Utils.debounce(this.dispatchPaletteChange.bind(this), 100);
          this.bound_clickColor = this.clickColor.bind(this);
          this.bound_onColorChange = this.onColorChange.bind(this);
          this.shadowRoot.querySelector('.palette-container').addEventListener('click', this.bound_clickColor);
          this.shadowRoot.querySelector('color-picker').addEventListener('change', this.bound_onColorChange);
          this.shadowRoot.querySelector('color-picker').addEventListener('change', this.bound_onColorChange);
        }
      
        disconnectedCallback() {
          this.shadowRoot.querySelector('.palette-container').removeEventListener('click', this.bound_clickColor);
          this.shadowRoot.querySelector('color-picker').removeEventListener('change', this.bound_onColorChange);
        }
      
        static get observedAttributes() {
          return ['count', 'color-count'];
        }
      
        attributeChangedCallback(name, _, newValue) {
          if (name === 'count') this.count = newValue;
          if (name === 'color-count') this.colorCount = newValue;
        }
      
        get count() {
          return this.count_ || 1;
        }
      
        set count(value) {
          value = parseInt(value);
          if (value < 1) value = 1;
          this.count_ = value;
          this.render();
        }
      
        get colorCount() {
          return this.colorCount_ || 4;
        }
      
        // TODO regenrate color if the colorCount increases
        set colorCount(value) {
          value = parseInt(value);
          if (value < 1) value = 1;
          this.colorCount_ = value;
          this.render();
        }
      
        get palettes() {
          let change = false;
          if (!this.palettes_) this.palettes_ = [...new Array(this.count)].map(() => this.generateDefaultPalette());
          if (this.palettes_.length < this.colorCount) {
            this.palettes_ = this.palettes_.concat([...new Array(this.colorCount - this.palettes_.length)].map(() => this.generateDefaultPalette()));
            change = true;
          }
          if (this.palettes_.length > this.colorCount) {
            [...new Array(this.palettes_.length - this.colorCount)].forEach(() => this.palettes_.pop());
            change = true;
          }
          if (change) this.palettes_.forEach(p => this.updatePalette(p));
          return this.palettes_;
        }
      
        get selected() {
          return this.selected_;
        }
      
        set selected(value) {
          if (!value.classList.contains('color')) throw Error('requires color element');
          this.selected_ = value;
        }
      
        get selectedColor() {
          if (!this.selected) return null;
          const location = this.selectedLocation;
          return this.palettes[location[0]][location[1]];
        }
      
        get selectedLocation() {
          if (!this.selected) return null;
          return this.selected.getAttribute('location').split('-');
        }
      
        get colorPicker() {
          return this.shadowRoot.querySelector('color-picker');
        }
      
        get selectedPalette() {
          return this.selectedPalette_;
        }
      
        set selectedPalette(value) {
          value = parseInt(value);
          if (value > this.count) value = this.count;
          this.selectedPalette_ = value;
        }
      
        isEdit() {
          return this.shadowRoot.querySelector('input[name="edit"]').checked;
        }
      
        generateDefaultPalette() {
          const step = 255 / this.colorCount;
          return [...new Array(this.colorCount)].map((_, i) => {
            const value = parseInt(step * i);
            return [value, value, value, 1];
          });
        }
      
        updatePalette(arr) {
          if (arr.length > this.colorCount) [...new Array(arr.length - this.colorCount)].forEach(() => arr.pop());
          if (arr.length < this.colorCount) {
            const defaults = this.generateDefaultPalette();
            [...new Array(this.colorCount - arr.length)].forEach((_, i) => arr.push(defaults[(arr.length - 1) + i]));
          }
        }
      
        clickColor(e) {
          this.selectPalette(e);
          if (!e.target.classList.contains('color')) {
            this.dispatchChange();
            return;
          }
      
          if (this.selected) this.selected.classList.remove('selected');
          this.selected = e.target;
          this.selected.classList.add('selected');
          this.dispatchChange();
        }
      
        onColorChange(e) {
          if (this.isEdit()) this.updateSelected(e.detail.color);
          this.dispatchChange();
        }
      
        selectPalette(e) {
          if (!e.target.classList.contains('palette-select')) return;
          [...this.shadowRoot.querySelectorAll('.palette-select')].forEach(el => el.checked = false);
          e.target.checked = true;
          this.selectedPalette = parseInt(e.target.getAttribute('id').replace('palette-', ''));
        }
      
        updateSelected(color) {
          if (!this.selected) return;
          const location = this.selectedLocation;
          this.palettes[location[0]][location[1]] = color;
          this.selected.style.backgroundColor = this.convertArrToRBGA(color);
          this.debounced_dispatchPaletteChange();
        }
      
        convertArrToRBGA(arr) {
          return `rgba(${arr.join(',')})`;
        }
      
        dispatchChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              selectedPalette: this.selectedPalette,
              selectedColor: this.selectedColor,
              pickerColor: this.colorPicker.color,
              palettes: this.palettes
            }
          }));
        }
      
        dispatchPaletteChange() {
          this.dispatchEvent(new CustomEvent('paletteChange', {
            detail: {
              selectedPalette: this.selectedPalette,
              selectedColor: this.selectedColor,
              pickerColor: this.colorPicker.color,
              palettes: this.palettes
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
            }
      
            .palette-container {
              width: 312px;
              margin: 6px;
            }
      
            .palette {
              display: flex;
              flex-direction: row;
              padding: 6px;
            }
      
            .color {
              flex: 1;
              height: 24px;
              border: 3px solid rgba(0,0,0,0);
              box-sizing: border-box;
            }
      
            .color:hover {
              border: 3px solid #AAA;
            }
      
            .color.selected {
              border: 3px solid rgb(0, 159, 218, 0.7);
            }
      
            .divider {
              border-bottom: 1px solid #999;
            }
      
            .spacer {
              padding-top: 12px;
            }
      
            .top-row {
              display: flex;
              align-items: center;
            }
      
            .title {
              margin-left: 32px;
              font-size: 18px;
              font-weight: 400;
              padding-left: 6px;
              flex: 1;
            }
      
            .edit-label {
              color: #666;
              font-size: 14px;
              font-weight: bold;
              padding-right: 6px;
            }
      
            .palette-select {
              margin-left: 8px;
              margin-right: 12px;
            }
          `;
        }
      
        template() {
          return html`
            <div class="palette-container">
              <div class="top-row">
                <div class="title">Palettes</div>
                <input type="checkbox" name="edit">
                <label class="edit-label" for="edit">Edit</label>
              </div>
              ${[...new Array(this.count)].map((_, i) => `
                ${i !== 0 ? '<div class="divider"></div>' : ''}
                <div class="palette">
                  <input type="checkbox" ${i === 0 ? 'checked' : ''} id="palette-${i}" class="palette-select">
                  ${[...new Array(this.colorCount)].map((_, j) => `
                    <div class="color" style="background-color: ${this.convertArrToRBGA(this.palettes[i][j])};" location="${i}-${j}"></div>
                  `).join('\n')}
                </div>
      
              `).join('\n')}
      
              <div class="spacer"></div>
              <color-picker></color-picker>
            </div>
          `;
        }
      
      
          
          
        
      
              render() {
                if (this.beforeRender) this.beforeRender();
                const renderBlock = this.shadowRoot.querySelector('render-block');
                if (!renderBlock) throw Error('Could not find <render-block>');
                renderBlock.innerHTML = this.template();
                if (this.afterRender) this.afterRender();
              }
      
              cloneTemplate(rerender = false) {
                var template = document.getElementById('palette-tool');
                var templateContent = template.content;
                var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
                var clone = templateContent.cloneNode(true);
                if (rerender) clone.querySelector('render-block').innerHTML = this.template();
                shadowRoot.appendChild(clone);
              }
            }
          );
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','draw-canvas');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        cursor: none;
      }
      
      .container {
        position: relative;
        cursor: none;
      }
      
      .cursor {
        position: absolute;
        z-index: 10;
        cursor: none;
        user-select: none;
        pointer-events: none;
        border: 1px solid #DDD;
        width: 4px;
        height: 4px;
      }
      
      .cursor.hide {
        display: none;
      }
      
      #tile-validation-canvas {
        position: absolute;
        left: 0px;
        top: 0px;
        user-select: none;
      }
      
      #grid-canvas {
        position: absolute;
        left: 0.5px;
        top: 0.5px;
        pointer-events: none;
        user-select: none;
      }
      
      #temp-canvas,
      #temp-canvas-2 {
        position: absolute;
        display: none;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="cursor"></div>
        <canvas id="backround-canvas" width="640" height="576"></canvas>
        <canvas id="grid-canvas" width="640" height="576"></canvas>
        <canvas id="tile-validation-canvas" width="640" height="576" style="pointer-events: none;"></canvas>
      </div>
      <canvas id="temp-canvas" width="0" height="0"></canvas>
      <canvas id="temp-canvas-2" width="0" height="0"></canvas>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("draw-canvas", 
            class drawCanvas extends HTMLElement {
              
          
        
          constructor() {
          super();
      
          this.canvasWidth = this.hasAttribute('width') ? parseInt(this.getAttribute('width')) : 160;
          this.canvasHeight = this.hasAttribute('height') ? parseInt(this.getAttribute('height')) : 144;
          this.scale_ = this.hasAttribute('scale') ? parseInt(this.getAttribute('scale')) : 4;
          this.color_ = [0, 0, 0, 1];
      
          this.cloneTemplate();
        }
          
      
        connectedCallback() {
          this.RGBAtoInt = new TilePaletteChecker().RGBAtoInt;
      
          const ctx = this.backgroundContext;
          this.bound_mouseDown = this.mouseDown.bind(this);
          this.bound_mouseUp = this.mouseUp.bind(this);
          this.bound_mouseLeave = this.mouseLeave.bind(this);
          this.bound_mouseMove = this.mouseMove.bind(this);
          this.bound_mouseEnter = this.mouseEnter.bind(this);
          this.bound_onContextMenu = this.onContextMenu.bind(this);
      
          // bind tile validation events
          this.bound_tileValidationMouseEnter = this.tileValidationMouseEnter.bind(this);
          this.bound_tileValidationMouseLeave = this.tileValidationMouseLeave.bind(this);
          this.bound_tileValidationMouseMove = this.tileValidationMouseMove.bind(this);
          this.bound_tileValidationClick = this.tileValidationClick.bind(this);
      
          this.addBackgroundEvents();
      
          ctx.fillStyle = 'white';
          ctx.scale(this.scale, this.scale);
          ctx.fillRect(0, 0, this.canvasWidth * this.scale, this.canvasHeight * this.scale);
      
          this.inited = true;
        }
      
        disconnectedCallback() {
          this.removeBackgroundEvents();
          this.removeTileValidationEvents();
          this.cursor_ = undefined;
        }
      
        addBackgroundEvents() {
          const canvas_ = this.backgroundCanvas;
          canvas_.addEventListener('mousedown', this.bound_mouseDown);
          canvas_.addEventListener('mouseup', this.bound_mouseUp);
          canvas_.addEventListener('mouseleave', this.bound_mouseLeave);
          canvas_.addEventListener('mousemove', this.bound_mouseMove);
          canvas_.addEventListener('mouseenter', this.bound_mouseEnter);
          canvas_.addEventListener('contextmenu', this.bound_onContextMenu);
        }
      
        removeBackgroundEvents() {
          const canvas_ = this.backgroundCanvas;
          canvas_.removeEventListener('mousedown', this.bound_mouseDown);
          canvas_.removeEventListener('mouseup', this.bound_mouseUp);
          canvas_.removeEventListener('mouseleave', this.bound_mouseLeave);
          canvas_.removeEventListener('mousemove', this.bound_mouseMove);
          canvas_.removeEventListener('mouseenter', this.bound_mouseEnter);
          canvas_.removeEventListener('contextmenu', this.bound_onContextMenu);
        }
      
        static get observedAttributes() {
          return ['width', 'height', 'scale', 'color', 'gridSize'];
        }
      
        attributeChangedCallback(name, oldValue, newValue) {
          if (!this.inited) return;
          if (name === 'scale') this.scale = newValue;
          if (name === 'color') this.color = newValue;
          if (name === 'gridSize') this.gridSize = newValue;
          if (name === 'width') this.width = newValue;
          if (name === 'height') this.height = newValue;
        }
      
        get color() {
          return this.convertToRGBA(this.color_);
        }
      
        get rawColor() {
          return this.color_;
        }
      
        set color(value) {
          if (!value) return;
          this.color_ = value;
          this.drawMainCursor();
        }
      
        get backgroundCanvas() {
          return this.shadowRoot.querySelector('#backround-canvas');
        }
      
        get backgroundContext() {
          return this.backgroundCanvas.getContext('2d');
        }
      
        get gridContext() {
          return this.shadowRoot.querySelector('#grid-canvas').getContext('2d');
        }
      
        get tileValidationContext() {
          return this.shadowRoot.querySelector('#tile-validation-canvas').getContext('2d');
        }
      
        get tempCanvas() {
          return this.shadowRoot.querySelector('#temp-canvas');
        }
      
        get tempContext() {
          return this.tempCanvas.getContext('2d');
        }
      
        get tempCanvas2() {
          return this.shadowRoot.querySelector('#temp-canvas-2');
        }
      
        get tempContext2() {
          return this.tempCanvas2.getContext('2d');
        }
      
        get width() {
          return this.canvasWidth;
        }
      
        set width(value) {
          this.canvasWidth = parseInt(value);
          this.storeCanvas();
          // disconnect listenres, we are going to redraw the screen and the elements will change
          this.disconnectedCallback();
          // redraw elements
          this.render();
          // add back evnets
          if (!this.showTileValidation_) this.addBackgroundEvents();
          else this.addTileValidationEvents();
          // redraw canvas
          this.redrawCanvas();
          // optional draw grid
          if (this.showGrid_) this.drawGrid();
          if (this.showTileValidation_) this.showTileValidation();
        }
      
        get height() {
          return this.canvasHeight;
        }
      
        set height(value) {
          this.canvasHeight = parseInt(value);
          this.storeCanvas();
          // disconnect listenres, we are going to redraw the screen and the elements will change
          this.disconnectedCallback();
          // redraw elements
          this.render();
          // add back evnets
          if (!this.showTileValidation_) this.addBackgroundEvents();
          else this.addTileValidationEvents();
          // redraw canvas
          this.redrawCanvas();
          // optional draw grid
          if (this.showGrid_) this.drawGrid();
          if (this.showTileValidation_) this.showTileValidation();
        }
      
        get scale() {
          return this.scale_;
        }
      
        set scale(value) {
          value = parseFloat(value);
          if (value < 1) value = 1;
          // store canvas before scale change
          this.storeCanvas();
      
          // update scale
          this.scale_ = value;
      
          if (this.inited) {
            // disconnect listenres, we are going to redraw the screen and the elements will change
            this.disconnectedCallback();
            // redraw elements
            this.render();
            // add back evnets
            if (!this.showTileValidation_) this.addBackgroundEvents();
            else this.addTileValidationEvents();
            // redraw canvas
            this.redrawCanvas();
            // optional draw grid
            if (this.showGrid_) this.drawGrid();
            if (this.showTileValidation_) this.showTileValidation();
          }
      
          this.drawMainCursor();
        }
      
        get cursor() {
          if (!this.cursor_) this.cursor_ = this.shadowRoot.querySelector('.cursor');
          return this.cursor_;
        }
      
        get gridSize() {
          return this.gridSize_ || { x: 8, y: 8 };
        }
      
        set gridSize({ x, y }) {
          this.gridSize_ = { x, y };
          if (this.showGrid_) this.drawGrid();
        }
      
        get tileWidth() {
          return this.tileWidth_;
        }
      
        set tileWidth(value) {
          this.tileWidth_ = parseInt(value);
        }
      
        get tileHeight() {
          return this.tileHeight_;
        }
      
        set tileHeight(value) {
          this.tileHeight_ = parseInt(value);
        }
      
        // --- bockground canvas events ---
        mouseDown(e) {
          // block right click
          if (e.which !== 1) return;
      
          this.isMouseDown = true;
          this.fillPixel(e.clientX, e.clientY);
        }
      
        mouseUp(e) {
          // block right click
          if (e.which !== 1) return;
      
          if (this.isMouseDown) this.dispatchPaint();
          this.isMouseDown = false;
        }
      
        mouseLeave(e) {
          this.clearCursor();
          if (this.isMouseDown) this.dispatchPaint();
          this.isMouseDown = false;
        }
      
        dispatchPaint() {
          this.dispatchEvent(new CustomEvent('paint'));
        }
      
        mouseEnter(e) {
          this.drawMainCursor();
          this.isMouseDown = false;
        }
      
        onContextMenu(e) {
          e.preventDefault();
        }
      
        mouseMove(e) {
          const bounds = this.getBoundingClientRect();
          if (this.isMouseDown) this.fillPixel(e.clientX, e.clientY);
          let [x, y] = this.snapToPixel(e.clientX - bounds.left, e.clientY - bounds.top);
          this.moveCursor(x, y);
        }
      
      
      
        // --- cursors ---
      
        moveCursor(x, y) {
          this.cursor.style.left = `${x}px`;
          this.cursor.style.top = `${y}px`;
        }
      
        drawMainCursor() {
          this.cursor.style.width = `${this.scale}px`;
          this.cursor.style.height = `${this.scale}px`;
          this.cursor.style.backgroundColor = this.color;
          this.cursor.style.border = '1px solid #DDD';
        }
      
        drawTileValidationCursor() {
          this.cursor.style.width = `${this.tileWidth * this.scale}px`;
          this.cursor.style.height = `${this.tileWidth * this.scale}px`;
          this.cursor.style.border = 'none';
          this.redValidationCursor();
        }
      
        greenValidationCursor() {
          this.cursor.style.backgroundColor = 'rgba(117, 217, 133, 0.4)';
        }
      
        redValidationCursor() {
          this.cursor.style.backgroundColor = 'rgba(255, 50, 50, 0.1)';
        }
      
        clearCursor() {
          this.cursor.style.backgroundColor = 'rgba(0, 0, 0, 0)';
          this.cursor.style.border = 'none';
        }
      
      
      
        drawImage(image, x, y) {
          this.backgroundContext.imageSmoothingEnabled = false;
          this.backgroundContext.drawImage(image, x, y);
          this.storeCanvas();
        }
      
        fillPixel(x, y) {
          const bounds = this.getBoundingClientRect();
          x -= bounds.left;
          y -= bounds.top;
          const [x2, y2] = this.snapToPixel(x, y);
          x = x2;
          y = y2;
      
          const ctx = this.backgroundContext;
          ctx.fillStyle = this.color;
          ctx.fillRect(x / this.scale, y / this.scale, 1, 1);
        }
      
        snapToPixel(x, y) {
          x -= x % this.scale;
          if (x < 0) x = 0;
          y -= y % this.scale;
          if (y < 0) y = 0;
          return [x, y];
        }
      
        convertToRGBA(value) {
          return `rgba(${value.join(',')})`;
        }
      
        getPixelCount() {
          return this.canvasWidth * this.canvasHeight;
        }
      
        redrawCanvas() {
          // copy to identical canvis of ientical size
          const tempCanvas = this.tempCanvas;
          tempCanvas.width = this.canvasData.width;
          tempCanvas.height = this.canvasData.height;
          this.tempContext.putImageData(this.canvasData, 0, 0);
      
          // use draw image, this has an option for streatching
          const ctx = this.backgroundContext;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(tempCanvas, 0, 0, this.canvasData.width, this.canvasData.height, 0, 0, this.canvasWidth * this.scale, this.canvasHeight * this.scale);
          ctx.scale(this.scale, this.scale);
        }
      
        storeCanvas() {
          this.canvasData = this.backgroundContext.getImageData(0, 0, this.canvasWidth * this.scale, this.canvasHeight * this.scale);
        }
      
        getNormalizedCanvasData() {
          this.storeCanvas();
      
          // copy to identical canvis of ientical size
          const tempCanvas = this.tempCanvas;
          tempCanvas.width = this.canvasData.width;
          tempCanvas.height = this.canvasData.height;
          this.tempContext.putImageData(this.canvasData, 0, 0);
      
          // use draw image, this has an option for streatching
          const tempCanvas2 = this.tempCanvas2;
          tempCanvas2.width = this.canvasWidth;
          tempCanvas2.height = this.canvasHeight;
          const ctx = this.tempContext2;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(tempCanvas, 0, 0, this.canvasData.width, this.canvasData.height, 0, 0, this.canvasWidth, this.canvasHeight);
      
          return ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);
        }
      
        showGrid() {
          ;
          this.showGrid_ = true;
          this.drawGrid();
        }
      
        hideGrid() {
          this.showGrid_ = false;
          this.gridContext.canvas.width = this.gridContext.canvas.width;
        }
      
        drawGrid() {
          const ctx = this.gridContext;
          const width = this.canvasWidth * this.scale;
          const height = this.canvasHeight * this.scale;
          const gridSizeX = this.gridSize.x * this.scale;
          const gridSizeY = this.gridSize.y * this.scale;
          let currentColumn = gridSizeX;
          let currentRow = gridSizeY;
          ctx.canvas.width = ctx.canvas.width;
      
          while (currentColumn < width) {
            ctx.moveTo(currentColumn, 0);
            ctx.lineTo(currentColumn, height);
            currentColumn += gridSizeX;
          }
      
          while (currentRow < height) {
            ctx.moveTo(0, currentRow);
            ctx.lineTo(width, currentRow);
            currentRow += gridSizeY;
          }
      
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.stroke();
        }
      
        getTileData() {
          const pData = this.getNormalizedCanvasData().data;
          const width = this.canvasWidth;
          const height = this.canvasHeight;
          const tileWidth = this.gridSize.x;
          const tileHeight = this.gridSize.y;
          const tileRowCount = width / tileWidth;
          const tileColors = [...new Array((width / tileWidth) * (height / tileHeight))].map(() => ({}));
          const rawTileData = [...new Array((width / tileWidth) * (height / tileHeight))].map(() => ([]));
          let currentRow = 0;
          let currentColumn = 0;
          let pixelCounter = 0;
      
          let tile = 0;
          let rawColor;
      
          for (; currentRow < height; currentRow += 1) {
            for (; currentColumn < width; currentColumn += 1) {
              tile = Math.floor(currentRow / tileHeight) * tileRowCount + Math.floor(currentColumn / tileWidth);
              rawColor = [pData[pixelCounter], pData[pixelCounter + 1], pData[pixelCounter + 2], pData[pixelCounter + 3] / 255];
              tileColors[tile][this.RGBAtoInt(rawColor)] = true;
              rawTileData[tile].push(rawColor);
              pixelCounter += 4;
            }
            currentColumn = 0;
          }
      
          return {
            tileColors,
            rawTileData
          };
        }
      
      
      
        // --- tile validation ---
      
        get tileValidation() {
          return this.tileValidation_;
        }
      
        set tileValidation(value) {
          this.tileValidation_ = value;
          if (value && this.showTileValidation_ === true) this.showTileValidation();
        }
      
        showTileValidation() {
          if (this.tileValidation) {
            this.showTileValidation_ = true;
            this.drawTileValidation();
            this.enableTileValidationEvents();
          } else {
            console.warn('cannot show validation because "tileValidation" data was not set');
          }
        }
      
        hideTileValidation() {
          console.log('hideTileValidation');
          this.showTileValidation_ = false;
          const ctx = this.tileValidationContext;
          ctx.canvas.width = ctx.canvas.width;
          this.shadowRoot.querySelector('#tile-validation-canvas').style.pointerEvents = 'none';
          this.drawMainCursor();
          this.addBackgroundEvents();
        }
      
        drawTileValidation() {
          const tileWidth = this.tileWidth * this.scale;
          const tileHeight = this.tileHeight * this.scale;
          const tileRowCount = this.canvasWidth / this.tileWidth;
          const ctx = this.tileValidationContext;
          ctx.canvas.width = ctx.canvas.width;
      
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = 'rgba(238,51,51,0.8)';
          this.tileValidation.tileValidationData.forEach(t => {
            if (!t.valid) {
              const y = Math.floor(t.tileId / tileRowCount) * tileHeight;
              const x = (t.tileId % tileRowCount) * tileWidth;
              ctx.strokeRect(x, y, tileWidth, tileHeight);
            }
          });
        }
      
        addTileValidationEvents() {
          const canvas_ = this.shadowRoot.querySelector('#tile-validation-canvas');
          canvas_.addEventListener('mouseleave', this.bound_tileValidationMouseLeave);
          canvas_.addEventListener('mousemove', this.bound_tileValidationMouseMove);
          canvas_.addEventListener('mouseenter', this.bound_tileValidationMouseEnter);
          canvas_.addEventListener('click', this.bound_tileValidationClick);
        }
      
        removeTileValidationEvents() {
          const canvas_ = this.shadowRoot.querySelector('#tile-validation-canvas');
          canvas_.removeEventListener('mouseleave', this.bound_tileValidationMouseLeave);
          canvas_.removeEventListener('mousemove', this.bound_tileValidationMouseMove);
          canvas_.removeEventListener('mouseenter', this.bound_tileValidationMouseEnter);
          canvas_.removeEventListener('click', this.bound_tileValidationClick);
        }
      
        tileValidationMouseEnter(e) {
          this.drawTileValidationCursor();
          this.isOnTileValidationCanvas = true;
        }
      
        tileValidationMouseLeave(e) {
          this.clearCursor();
          this.isOnTileValidationCanvas = false;
        }
      
        tileValidationMouseMove(e) {
          const bounds = this.getBoundingClientRect();
          const [x, y] = this.snapToTile(e.clientX - bounds.left, e.clientY - bounds.top);
          const tileWidth = this.tileWidth * this.scale;
          // check tile validity and updat cursor color
          const isTileValid = this.tileValidation.tileValidationData[(y / tileWidth) * (this.canvasWidth / this.tileWidth) + (x / tileWidth)].valid;
          if (isTileValid) this.greenValidationCursor();
          else this.redValidationCursor();
      
          this.moveCursor(x, y);
        }
      
        tileValidationClick(e) {
          const bounds = this.getBoundingClientRect();
          const tileWidth = this.tileWidth * this.scale;
          const tileHeight = this.tileHeight * this.scale;
          const tileRowCount = this.canvasWidth / this.tileWidth;
          let [x, y] = this.snapToTile(e.clientX - bounds.left, e.clientY - bounds.top);
          x /= tileWidth;
          y /= tileHeight;
          y *= tileRowCount;
          this.dispatchEvent(new CustomEvent('tileSelect', {
            detail: {
              selectedTile: x + y
            }
          }));
        }
      
        snapToTile(x, y) {
          x -= x % (this.tileWidth * this.scale);
          if (x < 0) x = 0;
          y -= y % (this.tileHeight * this.scale);
          if (y < 0) y = 0;
          return [x, y];
        }
      
      
        // --- events enablers ---
      
        enableDrawEvents() {
          this.disableTileValidationEvents();
          this.addBackgroundEvents();
        }
      
        disableDrawEvents() {
          this.removeBackgroundEvents();
        }
      
        enableTileValidationEvents() {
          this.disableDrawEvents();
          this.addTileValidationEvents();
          this.shadowRoot.querySelector('#tile-validation-canvas').style.pointerEvents = '';
        }
      
        disableTileValidationEvents() {
          this.removeTileValidationEvents();
          this.shadowRoot.querySelector('#tile-validation-canvas').style.pointerEvents = 'none';
        }
      
      
        styles() {
          return css`
            :host {
              display: block;
              cursor: none;
            }
      
            .container {
              position: relative;
              cursor: none;
            }
      
            .cursor {
              position: absolute;
              z-index: 10;
              cursor: none;
              user-select: none;
              pointer-events: none;
              border: 1px solid #DDD;
              width: 4px;
              height: 4px;
            }
      
            .cursor.hide {
              display: none;
            }
      
            #tile-validation-canvas {
              position: absolute;
              left: 0px;
              top: 0px;
              user-select: none;
            }
      
            #grid-canvas {
              position: absolute;
              left: 0.5px;
              top: 0.5px;
              pointer-events: none;
              user-select: none;
            }
      
            #temp-canvas,
            #temp-canvas-2 {
              position: absolute;
              display: none;
            }
          `;
        }
      
        template() {
          return html`
            <div class="container">
              <div class="cursor"></div>
              <canvas id="backround-canvas" width="${this.canvasWidth * this.scale}" height="${this.canvasHeight * this.scale}"></canvas>
              <canvas id="grid-canvas" width="${this.canvasWidth * this.scale}" height="${this.canvasHeight * this.scale}"></canvas>
              <canvas id="tile-validation-canvas" width="${this.canvasWidth * this.scale}" height="${this.canvasHeight * this.scale}" style="${this.showTileValidation_ ? '' : 'pointer-events: none;'}"></canvas>
            </div>
            <canvas id="temp-canvas" width="0" height="0"></canvas>
            <canvas id="temp-canvas-2" width="0" height="0"></canvas>
          `;
        }
      
      
          
          
        
      
              render() {
                if (this.beforeRender) this.beforeRender();
                const renderBlock = this.shadowRoot.querySelector('render-block');
                if (!renderBlock) throw Error('Could not find <render-block>');
                renderBlock.innerHTML = this.template();
                if (this.afterRender) this.afterRender();
              }
      
              cloneTemplate(rerender = false) {
                var template = document.getElementById('draw-canvas');
                var templateContent = template.content;
                var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
                var clone = templateContent.cloneNode(true);
                if (rerender) clone.querySelector('render-block').innerHTML = this.template();
                shadowRoot.appendChild(clone);
              }
            }
          );
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','scale-range');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        width: 180px;
        background-color: #DDD;
        border: 1px solid #AAA;
        border-radius: 3px;
        padding: 2px;
      }
      
      #scale-input {
        width: 20px;
        margin: 0;
      }
      
      #scale-range {
        width: 120px;
        height: 9px;
        padding-left: 4px;
      }
          </style>
          <render-block>
            <span>x</span>
      <input type="text" id="scale-input">
      <input type="range" min="1" max="10" value="" id="scale-range">
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("scale-range", 
            class scaleRange extends HTMLElement {
              
          
        
          constructor() {
          super();
          this.cloneTemplate();
        }
          
      
        connectedCallback() {
          this.bound_inputChange = this.inputChange.bind(this);
          this.bound_rangeChange = this.rangeChange.bind(this);
          this.inputEl.addEventListener('change', this.bound_inputChange);
          this.rangeEl.addEventListener('input', this.bound_rangeChange);
          this.max = this.hasAttribute('max') ? this.getAttribute('max') : 10;
          this.min = this.hasAttribute('min') ? this.getAttribute('min') : 1;
          this.value = this.hasAttribute('value') ? this.getAttribute('value') : 1;
          this.inited = true;
        }
      
        disconnectedCallback() {
          this.inputEl.removeEventListener('change', this.bound_inputChange);
          this.rangeEl.removeEventListener('input', this.bound_rangeChange);
        }
      
        static get observedAttributes() {
          return ['min', 'max'];
        }
      
        attributeChangedCallback(name, _, newValue) {
          if (name === 'min') this.min = newValue;
          if (name === 'maxt') this.max = newValue;
        }
      
        get min() {
          return this.min_;
        }
      
        set min(value) {
          value = parseInt(value);
          this.min_ = value;
        }
      
        get max() {
          return this.max_;
        }
      
        set max(value) {
          value = parseInt(value);
          this.max_ = value;
        }
      
        get inputEl() {
          return this.shadowRoot.querySelector('input[type="text"]');
        }
      
        get rangeEl() {
          return this.shadowRoot.querySelector('input[type="range"]');
        }
      
        get value() {
          return this.value_;
        }
      
        set value(v) {
          this.value_ = parseInt(v);
          if (this.value_ < this.min) this.value_ = this.min;
          if (this.value_ > this.max) this.value_ = this.max;
      
          this.rangeEl.removeEventListener('input', this.bound_inputChange);
          this.inputEl.removeEventListener('change', this.bound_inputChange);
          this.rangeEl.value = this.value_;
          this.inputEl.value = this.value_;
          this.rangeEl.addEventListener('input', this.bound_inputChange);
          this.inputEl.addEventListener('change', this.bound_inputChange);
          if (this.inited) this.handleChange();
        }
      
        inputChange(e) {
          this.value = this.inputEl.value;
        }
      
        rangeChange(e) {
          this.value = this.rangeEl.value;
        }
      
        handleChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              value: this.value
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
              width: 180px;
              background-color: #DDD;
              border: 1px solid #AAA;
              border-radius: 3px;
              padding: 2px;
            }
      
            #scale-input {
              width: 20px;
              margin: 0;
            }
      
            #scale-range {
              width: 120px;
              height: 9px;
              padding-left: 4px;
            }
          `;
        }
      
      
        template() {
          return html`
            <span>x</span>
            <input type="text" id="scale-input">
            <input type="range" min="1" max="10" value="${this.value}" id="scale-range">
          `;
        }
      
      
          
          
        
      
              render() {
                if (this.beforeRender) this.beforeRender();
                const renderBlock = this.shadowRoot.querySelector('render-block');
                if (!renderBlock) throw Error('Could not find <render-block>');
                renderBlock.innerHTML = this.template();
                if (this.afterRender) this.afterRender();
              }
      
              cloneTemplate(rerender = false) {
                var template = document.getElementById('scale-range');
                var templateContent = template.content;
                var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
                var clone = templateContent.cloneNode(true);
                if (rerender) clone.querySelector('render-block').innerHTML = this.template();
                shadowRoot.appendChild(clone);
              }
            }
          );
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','grid-settings');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        background-color: #DDD;
        border: 1px solid #AAA;
        border-radius: 3px;
        padding: 2px;
        padding-right: 8px;
      }
      
      .pixel-input {
        width: 20px;
        margin: 0;
      }
      
      span {
        font-size: 11px;
        color: #666;
      }
      
      label {
        font-size: 13px;
        color: #444;
      }
          </style>
          <render-block>
            <span>Grid</span>
      <input type="checkbox">
      <label>X</label>
      <input type="text" class="pixel-input" id="input-x">
      <span>px</span>
      <label>Y</label>
      <input type="text" class="pixel-input" id="input-y">
      <span>px</span>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("grid-settings", 
            class gridSettings extends HTMLElement {
              
          
        
          constructor() {
          super();
          this.cloneTemplate();
        }
          
      
        connectedCallback() {
          this.valueX = 8;
          this.valueY = 8;
          this.bound_inputXChange = this.inputXChange.bind(this);
          this.bound_inputYChange = this.inputYChange.bind(this);
          this.bound_checkboxChange = this.checkboxChange.bind(this);
          this.inputX.addEventListener('change', this.bound_inputXChange);
          this.inputY.addEventListener('change', this.bound_inputYChange);
          this.checkbox.addEventListener('change', this.bound_checkboxChange);
        }
      
        disconnectedCallback() {
          this.inputX.removeEventListener('change', this.bound_inputXChange);
          this.inputY.removeEventListener('change', this.bound_inputYChange);
          this.checkbox.removeEventListener('change', this.bound_checkboxChange);
        }
      
        get inputX() {
          return this.shadowRoot.querySelector('#input-x');
        }
      
        get inputY() {
          return this.shadowRoot.querySelector('#input-y');
        }
      
        get checkbox() {
          return this.shadowRoot.querySelector('input[type="checkbox"]');
        }
      
        get show() {
          return this.show_;
        }
      
        set show(value) {
          this.show_ = value;
        }
      
        get valueX() {
          return this.valueX_;
        }
      
        set valueX(value) {
          this.valueX_ = value;
          this.inputX.value = value;
        }
      
        get valueY() {
          return this.valueY_;
        }
      
        set valueY(value) {
          this.valueY_ = value;
          this.inputY.value = value;
        }
      
        inputXChange(e) {
          this.valueX = this.inputX.value;
          this.handleChange();
        }
      
        inputYChange(e) {
          this.valueY = this.inputY.value;
          this.handleChange();
        }
      
        checkboxChange(e) {
          this.show = this.checkbox.checked;
          this.handleChange();
        }
      
        handleChange() {
          this.dispatchEvent(new CustomEvent('change', {
            detail: {
              show: this.show,
              valueX: this.valueX,
              valueY: this.valueY
            }
          }));
        }
      
        styles() {
          return css`
            :host {
              display: block;
              background-color: #DDD;
              border: 1px solid #AAA;
              border-radius: 3px;
              padding: 2px;
              padding-right: 8px;
            }
      
            .pixel-input {
              width: 20px;
              margin: 0;
            }
      
            span {
              font-size: 11px;
              color: #666;
            }
      
            label {
              font-size: 13px;
              color: #444;
            }
          `;
        }
      
      
        template() {
          return html`
            <span>Grid</span>
            <input type="checkbox">
            <label>X</label>
            <input type="text" class="pixel-input" id="input-x">
            <span>px</span>
            <label>Y</label>
            <input type="text" class="pixel-input" id="input-y">
            <span>px</span>
          `;
        }
      
      
          
          
        
      
              render() {
                if (this.beforeRender) this.beforeRender();
                const renderBlock = this.shadowRoot.querySelector('render-block');
                if (!renderBlock) throw Error('Could not find <render-block>');
                renderBlock.innerHTML = this.template();
                if (this.afterRender) this.afterRender();
              }
      
              cloneTemplate(rerender = false) {
                var template = document.getElementById('grid-settings');
                var templateContent = template.content;
                var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
                var clone = templateContent.cloneNode(true);
                if (rerender) clone.querySelector('render-block').innerHTML = this.template();
                shadowRoot.appendChild(clone);
              }
            }
          );
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','entry-dialog');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 11;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .container {
        display: inline-block;
        position: relative;
        left: 50%;
        top: 50%;
        width: 500px;
        height: auto;
        transform: translate(-50%, -50%);
      
        background-color: #DDD;
        border: 1px solid #999;
        border-radius: 3px;
        box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                    0 8px 10px 1px rgba(0,0,0,.14),
                    0 3px 14px 2px rgba(0,0,0,.12);
      }
      
      .title-bar {
        padding: 8px;
        padding-left: 16px;
        background-color: #CCC;
        border-bottom: 1px solid #aaa;
      }
      
      .title {
        font-size: 22px;
        font-weight: bold;
        color: #444;
      }
      
      .sub-title {
        font-size: 20px;
        color: #444;
        margin-bottom: 18px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      .choice-container {
        display: flex;
        flex-direction: row;
        padding: 24px;
      }
      
      .choice-1 {
        flex: 3;
        display: flex;
        flex-direction: column;
      }
      
      .choice-2 {
        flex: 2;
        display: flex;
        flex-direction: column;
      }
      
      .control-container {
        padding-bottom: 20px;
      }
      
      .control-container label {
        font-size: 17px;
        color: #666;
      }
      
      .control-container input {
        width: 40px;
      }
      
      .control-container span {
        color: #999;
        font-size: 11px;
        padding-right: 16px;
      }
      
      .controls {
        padding-top: 12px;
      }
      
      button {
        align-items: center;
        border: none;
        border-radius: 4px;
        box-sizing: border-box;
        display: inline-flex;
        font-size: 14px;
        font-weight: 500;
        height: 33px;
        justify-content: center;
        line-height: 32px;
        min-width: 64px;
        outline: none;
        overflow: hidden;
        padding: 0 8px 0 8px;
        position: relative;
        vertical-align: middle;
        margin: 0;
        background-color: white;
      }
      
      button:hover {
        cursor: pointer;
        background-color: #EEE;
      }
          </style>
          <render-block>
            <div class="container">
        <div class="choice-container">
          <div class="choice-1">
            <span class="sub-title">Create</span>
      
            <div class="sub-header">Canvas size</div>
            <div class="control-container">
              <label for="pixels-x">x</label>
              <input name="pixels-x" type="number" value="160" >
              <span>px</span>
              <label for="pixels-x">y</label>
              <input name="pixels-y" type="number" value="144" >
              <span>px</span>
            </div>
      
            <div class="sub-header">Tile size</div>
            <div class="control-container">
              <label for="tile-x">x</label>
              <input name="tile-x" type="number" value="8" >
              <span>px</span>
      
              <label for="tile-y">y</label>
              <input name="tile-y" type="number" value="8" >
              <span>px</span>
            </div>
      
            <div class="sub-header">Palettes</div>
            <div class="control-container">
              <label for="palette-count">count </label>
              <input name="palette-count" type="number" value="1" >
              <br/>
              <label for="palette-color-count">colors</label>
              <input name="palette-color-count" type="number" value="4" >
              <span>per palette</span>
            </div>
      
            <div class="controls">
              <button id="create">create</button>
            </div>
          </div>
          <div class="choice-2">
            <span class="sub-title">Open</span>
            <div class="controls">
              <button>choose...</button>
            </div>
          </div>
        </div>
      </div>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("entry-dialog", 
            class entryDialog extends HTMLElement {
              
          
        
          constructor() {
          super();
          this.cloneTemplate();
        }
          
      
        connectedCallback() {
          this.bound_create = this.create.bind(this);
          this.createButton.addEventListener('click', this.bound_create);
        }
      
        disconnectedCallback() {
          this.createButton.removeEventListener('click', this.bound_create);
        }
      
        get createButton() {
          return this.shadowRoot.querySelector('#create');
        }
      
        get pixelsX() {
          return this.shadowRoot.querySelector('input[name="pixels-x"]').value;
        }
      
        get pixelsY() {
          return this.shadowRoot.querySelector('input[name="pixels-y"]').value;
        }
      
        get tileX() {
          return this.shadowRoot.querySelector('input[name="tile-x"]').value;
        }
      
        get tileY() {
          return this.shadowRoot.querySelector('input[name="tile-y"]').value;
        }
      
        get paletteCount() {
          return this.shadowRoot.querySelector('input[name="palette-count"]').value;
        }
      
        get paletteColorCount() {
          return this.shadowRoot.querySelector('input[name="palette-color-count"]').value;
        }
      
        create() {
          this.dispatchEvent(new CustomEvent('create', {
            detail: {
              size: {
                x: this.pixelsX,
                y: this.pixelsY
              },
              tile: {
                x: this.tileX,
                y: this.tileY
              },
              palette: {
                count: this.paletteCount,
                colorCount: this.paletteColorCount
              }
            }
          }));
          this.remove();
        }
      
        styles() {
          return css`
            :host {
              display: block;
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              z-index: 11;
              background-color: rgba(0, 0, 0, 0.5);
            }
      
            .container {
              display: inline-block;
              position: relative;
              left: 50%;
              top: 50%;
              width: 500px;
              height: auto;
              transform: translate(-50%, -50%);
      
              background-color: #DDD;
              border: 1px solid #999;
              border-radius: 3px;
              box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),
                          0 8px 10px 1px rgba(0,0,0,.14),
                          0 3px 14px 2px rgba(0,0,0,.12);
            }
      
            .title-bar {
              padding: 8px;
              padding-left: 16px;
              background-color: #CCC;
              border-bottom: 1px solid #aaa;
            }
      
            .title {
              font-size: 22px;
              font-weight: bold;
              color: #444;
            }
      
            .sub-title {
              font-size: 20px;
              color: #444;
              margin-bottom: 18px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            .choice-container {
              display: flex;
              flex-direction: row;
              padding: 24px;
            }
      
            .choice-1 {
              flex: 3;
              display: flex;
              flex-direction: column;
            }
      
            .choice-2 {
              flex: 2;
              display: flex;
              flex-direction: column;
            }
      
            .control-container {
              padding-bottom: 20px;
            }
      
            .control-container label {
              font-size: 17px;
              color: #666;
            }
      
            .control-container input {
              width: 40px;
            }
      
            .control-container span {
              color: #999;
              font-size: 11px;
              padding-right: 16px;
            }
      
            .controls {
              padding-top: 12px;
            }
      
            button {
              align-items: center;
              border: none;
              border-radius: 4px;
              box-sizing: border-box;
              display: inline-flex;
              font-size: 14px;
              font-weight: 500;
              height: 33px;
              justify-content: center;
              line-height: 32px;
              min-width: 64px;
              outline: none;
              overflow: hidden;
              padding: 0 8px 0 8px;
              position: relative;
              vertical-align: middle;
              margin: 0;
              background-color: white;
            }
      
            button:hover {
              cursor: pointer;
              background-color: #EEE;
            }
          `;
        }
      
      
        template() {
          return html`
            <div class="container">
              <div class="choice-container">
                <div class="choice-1">
                  <span class="sub-title">Create</span>
      
                  <div class="sub-header">Canvas size</div>
                  <div class="control-container">
                    <label for="pixels-x">x</label>
                    <input name="pixels-x" type="number" value="160" >
                    <span>px</span>
                    <label for="pixels-x">y</label>
                    <input name="pixels-y" type="number" value="144" >
                    <span>px</span>
                  </div>
      
                  <div class="sub-header">Tile size</div>
                  <div class="control-container">
                    <label for="tile-x">x</label>
                    <input name="tile-x" type="number" value="8" >
                    <span>px</span>
      
                    <label for="tile-y">y</label>
                    <input name="tile-y" type="number" value="8" >
                    <span>px</span>
                  </div>
      
                  <div class="sub-header">Palettes</div>
                  <div class="control-container">
                    <label for="palette-count">count </label>
                    <input name="palette-count" type="number" value="1" >
                    <br/>
                    <label for="palette-color-count">colors</label>
                    <input name="palette-color-count" type="number" value="4" >
                    <span>per palette</span>
                  </div>
      
                  <div class="controls">
                    <button id="create">create</button>
                  </div>
                </div>
                <div class="choice-2">
                  <span class="sub-title">Open</span>
                  <div class="controls">
                    <button>choose...</button>
                  </div>
                </div>
              </div>
            </div>
          `;
        }
      
      
          
          
        
      
              render() {
                if (this.beforeRender) this.beforeRender();
                const renderBlock = this.shadowRoot.querySelector('render-block');
                if (!renderBlock) throw Error('Could not find <render-block>');
                renderBlock.innerHTML = this.template();
                if (this.afterRender) this.afterRender();
              }
      
              cloneTemplate(rerender = false) {
                var template = document.getElementById('entry-dialog');
                var templateContent = template.content;
                var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
                var clone = templateContent.cloneNode(true);
                if (rerender) clone.querySelector('render-block').innerHTML = this.template();
                shadowRoot.appendChild(clone);
              }
            }
          );
      
      (function(){
          var t=document.createElement('template');
          t.setAttribute('id','tile-palette-validator');
          t.innerHTML=`
          <style>
            :host {
        display: block;
        background-color: #DDD;
        border-left: 1px solid #AAA;
        border-right: 1px solid #AAA;
        padding: 4px;
        padding-right: 8px;
      }
      
      .sub-header {
        font-size: 16px;
        color: #777;
        margin-bottom: 4px;
      }
      
      label {
        color: #666;
        font-size: 14px;
        font-weight: bold;
        padding-right: 6px;
      }
      
      .label {
        font-size: 14px;
        font-weight: bold;
        color: #777;
      }
      
      .value {
        width: 40px;
        padding-left: 4px;
      }
      
      .row {
        display: flex;
        flex-direction: row;
      }
      
      .column {
        display: flex;
        flex-direction: column;
      }
      
      section {
        margin-top: 6px;
        padding: 6px;
      }
      
      .reason {
        font-size: 12px;
        color: #777;
        margin-top: -8px;
        margin-left: 1px;
        margin-bottom: 12px;
      }
      
      .reason.warn {
        color: #ff3a3a;
      }
      
      .reason.success {
        color: #8aff39;
      }
          </style>
          <render-block>
            <div class="row">
        <input id="validation-mode-checkbox" type="checkbox" >
        <label style="padding-right: 8px;">Tile validation mode</label>
        <input id="enable-draw" type="checkbox"  >
        <label>Enable draw</label>
      
      
        <span style="flex: 1"></span>
        <span class="label">Invalid tiles: </span><span class="value"></span>
      </div>
      
      <section>
        <div class="sub-header">Selected tile</div>
        <div>
          <div class="reason">No tile selected</div>
        </div>
      </section>
          </render-block>
          `;
          document.body.insertAdjacentElement('beforeend', t);
        }());
      
      customElements.define("tile-palette-validator", 
            class tilePaletteValidator extends HTMLElement {
              
          
        
          constructor() {
          super();
      
          this.tileDisplayWidth = 80;
          this.tileDisplayHeight = 80;
          this.tileDrawScale = 10;
      
          this.cloneTemplate();
        }
          
      
        connectedCallback() {
          this.tilePaletteChecker = new TilePaletteChecker(this.canvas, this.paletteTool);
          this.bound_onTileSelect = this.onTileSelect.bind(this);
          this.bound_onCheckboxChange = this.onCheckboxChange.bind(this);
          this.bound_enableDrawClick = this.enableDrawClick.bind(this);
          this.bound_onPaint = this.onPaint.bind(this);
          this.bound_onPaletteChange = this.onPaletteChange.bind(this);
          this.addEvents();
        }
      
        disconnectedCallback() {
          this.removeEvents();
        }
      
        beforeRender() {
          this.removeEvents();
        }
      
        afterRender() {
          this.addEvents();
        }
      
        addEvents() {
          this.validationModeCheckbox.addEventListener('change', this.bound_onCheckboxChange);
          this.enableDrawCheckbox.addEventListener('change', this.bound_enableDrawClick);
      
          if (this.paletteTool) {
            if (this.validationModeChecked_) this.paletteTool.addEventListener('paletteChange', this.bound_onPaletteChange);
          }
      
          if (this.canvas_) {
            this.canvas_.addEventListener('tileSelect', this.bound_onTileSelect);
            if (this.drawEnabled) this.canvas_.addEventListener('paint', this.bound_onPaint);
          }
        }
      
        removeEvents() {
          this.validationModeCheckbox.removeEventListener('change', this.bound_onCheckboxChange);
          this.enableDrawCheckbox.removeEventListener('change', this.bound_enableDrawClick);
      
          if (this.paletteTool) this.paletteTool.removeEventListener('paletteChange', this.bound_onPaletteChange);
      
          if (this.canvas_) {
            this.canvas_.removeEventListener('tileSelect', this.bound_onTileSelect);
            this.canvas_.removeEventListener('paint', this.bound_onPaint);
          }
        }
      
        get canvas() {
          return this.canvas_;
        }
      
        set canvas(value) {
          this.canvas_ = value;
          // calculate width based on aspect ratio of tile
          this.tileDisplayWidth = (this.canvas_.tileWidth / this.canvas_.tileHeight) * this.tileDisplayHeight;
          this.tileDrawScale = this.tileDisplayHeight / this.canvas_.tileHeight;
          this.tilePaletteChecker.canvas = value;
          this.canvas_.addEventListener('tileSelect', this.bound_onTileSelect);
        }
      
        get paletteTool() {
          return this.paletteTool_;
        }
      
        set paletteTool(value) {
          this.paletteTool_ = value;
          this.tilePaletteChecker.paletteTool = value;
        }
      
        get validationModeCheckbox() {
          return this.shadowRoot.querySelector('#validation-mode-checkbox');
        }
      
        get enableDrawCheckbox() {
          return this.shadowRoot.querySelector('#enable-draw');
        }
      
        enableDrawClick(e) {
          if (this.drawEnabled) {
            this.disableDraw();
          } else {
            this.enableDraw();
          }
        }
      
        enableDraw() {
          this.drawEnabled = true;
          this.canvas.enableDrawEvents();
          this.canvas.addEventListener('paint', this.bound_onPaint);
        }
      
        disableDraw() {
          this.drawEnabled = false;
          this.canvas.enableTileValidationEvents();
          this.canvas.removeEventListener('paint', this.bound_onPaint);
        }
      
        check() {
          this.data = this.tilePaletteChecker.check();
          this.canvas.tileValidation = this.data;
          this.render();
        }
      
        showCanvas() {
          this.canvas.showTileValidation();
        }
      
        hideCanvas() {
          this.canvas.hideTileValidation();
        }
      
        onCheckboxChange(e) {
          if (this.validationModeCheckbox.checked) {
            this.validationModeChecked_ = true;
            this.check();
            this.showCanvas();
            this.paletteTool.addEventListener('paletteChange', this.bound_onPaletteChange);
          } else {
            this.validationModeChecked_ = false;
            this.selected = undefined;
            this.hideCanvas();
            this.render();
            this.paletteTool.removeEventListener('paletteChange', this.bound_onPaletteChange);
          }
        }
      
        onTileSelect(e) {
          this.selected = e.detail.selectedTile;
          this.render();
          this.drawTile();
        }
      
        drawTile() {
          const tileCanvas = this.shadowRoot.querySelector('#selected-tile-canvas');
          if (!tileCanvas) return;
      
          const ctx = tileCanvas.getContext('2d');
          const pixelScale = this.tileDrawScale;
          const tileData = this.data.rawTileData[this.selected];
          const pixelsX = this.canvas.tileWidth;
          const pixelsY = this.canvas.tileHeight;
          let x;
          let y = 0;
      
          this.clearTile();
      
          for(; y < pixelsY; y += 1) {
            for(x = 0; x < pixelsX; x += 1) {
              ctx.fillStyle = `rgba(${tileData[y * pixelsX + x].join(',')})`;
              ctx.fillRect(x * pixelScale, y * pixelScale, pixelScale, pixelScale);
            }
          }
        }
      
        clearTile() {
          this.shadowRoot.querySelector('#selected-tile-canvas').width = this.tileDisplayWidth;
        }
      
        onPaint() {
          this.check();
          this.drawTile();
        }
      
        onPaletteChange(e) {
          console.log('paletteChange');
          this.check();
          this.drawTile();
        }
      
        styles() {
          return css`
            :host {
              display: block;
              background-color: #DDD;
              border-left: 1px solid #AAA;
              border-right: 1px solid #AAA;
              padding: 4px;
              padding-right: 8px;
            }
      
            .sub-header {
              font-size: 16px;
              color: #777;
              margin-bottom: 4px;
            }
      
            label {
              color: #666;
              font-size: 14px;
              font-weight: bold;
              padding-right: 6px;
            }
      
            .label {
              font-size: 14px;
              font-weight: bold;
              color: #777;
            }
      
            .value {
              width: 40px;
              padding-left: 4px;
            }
      
            .row {
              display: flex;
              flex-direction: row;
            }
      
            .column {
              display: flex;
              flex-direction: column;
            }
      
            section {
              margin-top: 6px;
              padding: 6px;
            }
      
            .reason {
              font-size: 12px;
              color: #777;
              margin-top: -8px;
              margin-left: 1px;
              margin-bottom: 12px;
            }
      
            .reason.warn {
              color: #ff3a3a;
            }
      
            .reason.success {
              color: #8aff39;
            }
          `;
        }
      
      
        template() {
          const valid = this.selected !== undefined ? this.data.tileValidationData[this.selected].valid : false;
          return html`
            <div class="row">
              <input id="validation-mode-checkbox" type="checkbox" ${this.validationModeChecked_ ? 'checked' : ''}>
              <label style="padding-right: 8px;">Tile validation mode</label>
              <input id="enable-draw" type="checkbox" ${this.drawEnabled ? 'checked' : ''} >
              <label>Enable draw</label>
      
      
              <span style="flex: 1"></span>
              <span class="label">Invalid tiles: </span><span class="value">${this.data ? this.data.invalidTiles.length : ''}</span>
            </div>
      
            <section>
              <div class="sub-header">Selected tile</div>
              <div>
                ${this.selected === undefined ?
                  html`
                    <div class="reason">No tile selected</div>
                  ` :
                  html`
                    <div class="reason warn" style="${!valid ? '' : 'display: none;'}">${this.data.tileValidationData[this.selected].reason}</div>
                    <div class="reason success" style="${valid ? '' : 'display: none;'}">Valid</div>
                    <div class="row">
                      <canvas id="selected-tile-canvas" width="${this.tileDisplayWidth}" height="${this.tileDisplayHeight}"></canvas>
                    </div>
                  `
                }
              </div>
            </section>
          `;
        }
      
      
          
          
        
      
              render() {
                if (this.beforeRender) this.beforeRender();
                const renderBlock = this.shadowRoot.querySelector('render-block');
                if (!renderBlock) throw Error('Could not find <render-block>');
                renderBlock.innerHTML = this.template();
                if (this.afterRender) this.afterRender();
              }
      
              cloneTemplate(rerender = false) {
                var template = document.getElementById('tile-palette-validator');
                var templateContent = template.content;
                var shadowRoot = this.shadowRoot ? this.shadowRoot : this.attachShadow({mode: 'open'});
                var clone = templateContent.cloneNode(true);
                if (rerender) clone.querySelector('render-block').innerHTML = this.template();
                shadowRoot.appendChild(clone);
              }
            }
          );
          });
        
    
      class Home extends Page {
        constructor() {
          super();
      
          this.canvasWidth = 160;
          this.canvasHeight = 144;
          this.scale = 4;
          this.diableEntry = true;
        }
      
        connectedCallback() {
          this.bound_paletteChange = this.paletteChange.bind(this);
          this.paletteTool.addEventListener('change', this.bound_paletteChange);
          this.centerCanvas();
          this.canvas.color = this.paletteTool.selectedColor;
          this.canvas.tileWidth = 8;
          this.canvas.tileHeight = 8;
          this.bound_onCreate = this.onCreate.bind(this);
          if (!this.diableEntry) this.entryDialog.addEventListener('create', this.bound_onCreate);
      
          this.tilePaletteValidator.canvas = this.canvas;
          this.tilePaletteValidator.paletteTool = this.paletteTool;
        }
      
        disconnectedCallback() {
          this.paletteTool.removeEventListener('change', this.bound_paletteChange);
          if (!this.diableEntry) this.entryDialog.removeEventListener('create', this.bound_onCreate);
        }
      
        get title() {
          return 'Home';
        }
      
        get paletteTool() {
          return document.querySelector('palette-tool');
        }
      
        get canvas() {
          return document.querySelector('draw-canvas');
        }
      
        get entryDialog() {
          return document.querySelector('entry-dialog');
        }
      
        get tilePaletteValidator() {
          return document.querySelector('tile-palette-validator');
        }
      
        paletteChange(e) {
          this.canvas.color = e.detail.selectedColor;
        }
      
        onCreate(e) {
          this.entryDialog.removeEventListener('create', this.bound_onCreate);
      
          // set tile size and update the grid overlay settings
          const gridSettings = document.querySelector('grid-settings');
          gridSettings.valueX = e.detail.tile.x;
          gridSettings.valueY = e.detail.tile.y;
          this.canvas.tileWidth = e.detail.tile.x;
          this.canvas.tileHeight = e.detail.tile.y;
      
          // set canvas size
          // TODO implament cancas size
          this.canvasWidth = e.detail.size.x;
          this.canvasHeight = e.detail.size.y;
          this.canvas.width = this.canvasWidth;
          this.canvas.height = this.canvasHeight;
          this.centerCanvas();
      
          // set palette
          this.paletteTool.colorCount = e.detail.palette.colorCount;
          this.paletteTool.count = e.detail.palette.count;
        }
      
        centerCanvas() {
          const canvasPlane = document.querySelector('.canvas-plane');
          const containerBounds = document.querySelector('.canvas-container').getBoundingClientRect();
          const canvasBounds = this.canvas.getBoundingClientRect();
          canvasPlane.style.left = `${(containerBounds.width / 2) - (canvasBounds.width / 2)}px`;
          canvasPlane.style.top = `${(containerBounds.height / 2) - (canvasBounds.height / 2)}px`;
        }
      
        scaleCanvas(scale) {
          this.canvas.scale = scale;
          this.centerCanvas();
        }
      
        updateGrid(show, x, y) {
          if (show) {
            this.canvas.gridSize = {x, y};
            this.canvas.showGrid();
          } else this.canvas.hideGrid();
        }
      
        loadImage(el) {
          if(el.files.length === 0) return;
          const file = el.files[0];
          if(file.type !== '' && !file.type.match('image.*')) return;
      
          const image = new Image();
          image.addEventListener('load', () => {
            this.canvas.drawImage(image, 0, 0);
          }, false);
          image.src = window.URL.createObjectURL(file);
        }
      
        // toggleTileValidation() {
        //   document.querySelector('#validate-tile-on').style.display = 'none';
        //   document.querySelector('#validate-tile-off').style.display = 'none';
        //   if (!this.tileValidationOn) {
        //     this.tileValidationOn = true;
        //     document.querySelector('#validate-tile-on').style.display = 'block';
        //     this.tilePaletteValidator.check();
        //     this.tilePaletteValidator.showCanvas();
        //   } else {
        //     this.tileValidationOn = false;
        //     document.querySelector('#validate-tile-off').style.display = 'block';
        //   }
        // }
      
        template() {
          return html`
            ${!this.diableEntry ? '<entry-dialog></entry-dialog>' : ''}
      
            <div class="main-container">
              <div class="tool-bar">
                <div class="icon-button">edit</div>
                <div class="icon-button">brush</div>
                <div class="icon-button">colorize</div>
                <div class="icon-button">check</div>
                <!-- <div class="icon-button-svg" onclick="$Home.toggleTileValidation()">
                  <img id="validate-tile-on" src="earth-box.svg" alt="validate-tile-on" style="display: none;">
                  <img id="validate-tile-off" src="earth-box-off.svg" alt="validate-tile-off">
                </div> -->
                <div style="flex: 1;"></div>
                <label for="fileChooser" class="icon-button">image</label>
                <input hidden="true" type="file" name="fileChooser" id="fileChooser" accept="image/jpeg,image/png" onchange="$Home.loadImage(this)">
                <div class="icon-button">save</div>
              </div>
              <div class="canvas-container">
                <div class="canvas-plane">
                  <!-- TODO replace with component -->
                  <draw-canvas width="${this.canvasWidth}" height="${this.canvasHeight}" scale="4"></draw-canvas>
                </div>
                <div class="scale-container">
                  <tile-palette-validator></tile-palette-validator>
                  <scale-range min="1" max="10" value="4" onchange="$Home.scaleCanvas(this.value)"></scale-range>
                  <grid-settings onchange="$Home.updateGrid(this.show, this.valueX, this.valueY)"></grid-settings>
                </div>
              </div>
              <div class="settings-container">
                <palette-tool count="4" color-count="4"></palette-tool>
              </div>
            </div>
          `;
        }
      }
    
      window.$Home = new Home();
      window.currentPageClass = window.$Home;
      setTimeout(function () {
        $Home.connectedCallback();
      }, 0);
    </script>
    
    <style>
      
      
      
      
      
      
      
    </style>
  </head>

  <body>
    <render-block-page>
      <div class="main-container">
        <div class="tool-bar">
          <div class="icon-button">edit</div>
          <div class="icon-button">brush</div>
          <div class="icon-button">colorize</div>
          <div class="icon-button">check</div>
          <!-- <div class="icon-button-svg" onclick="$Home.toggleTileValidation()">
            <img id="validate-tile-on" src="earth-box.svg" alt="validate-tile-on" style="display: none;">
            <img id="validate-tile-off" src="earth-box-off.svg" alt="validate-tile-off">
          </div> -->
          <div style="flex: 1;"></div>
          <label for="fileChooser" class="icon-button">image</label>
          <input hidden="true" type="file" name="fileChooser" id="fileChooser" accept="image/jpeg,image/png" onchange="$Home.loadImage(this)">
          <div class="icon-button">save</div>
        </div>
        <div class="canvas-container">
          <div class="canvas-plane">
            <!-- TODO replace with component -->
            <draw-canvas width="160" height="144" scale="4"></draw-canvas>
          </div>
          <div class="scale-container">
            <tile-palette-validator></tile-palette-validator>
            <scale-range min="1" max="10" value="4" onchange="$Home.scaleCanvas(this.value)"></scale-range>
            <grid-settings onchange="$Home.updateGrid(this.show, this.valueX, this.valueY)"></grid-settings>
          </div>
        </div>
        <div class="settings-container">
          <palette-tool count="4" color-count="4"></palette-tool>
        </div>
      </div>
    </render-block-page>
  </body>
</html>